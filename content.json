[{"title":"SpringMVC 整合 Mockito单元测试","date":"2022-06-09T05:56:11.000Z","path":"2022/06/09/spring-mockito/","text":"不积跬步无以至千里，不积小流无以成江海 一、背景 在日常开发编码中，经常会遇到这样的场景：开发接口的过程中，有部分数据依赖同事开发的接口，需要等到同事的接口开发完成以后，才能开始我们的功能开发。这样依赖同事，有时候会影响到项目的上线节奏，所以我们在寻找有没能够解决这种场景的工具。 或者说，我们在分析完业务需求后，设计验证大的业务流程的代码的时候，也可以用到此类工具。首先把整体的大的处理逻辑完成，把细枝末节的处理打上标记 ToDo。 Mockito 可以帮助我们在编写单元测试类的时候，调用指定接口返回指定的数据信息。通过模拟数据，替代真实数据，这样我们不需要等到同事的接口开发完成后，再开始我们的工作，做到“并行开发”。 二、实施过程 1. 引入依赖 1234567&lt;!-- 引入mockito 依赖 --&gt;&lt;dependency&gt; &lt;groupId&gt;org.mockito&lt;/groupId&gt; &lt;artifactId&gt;mockito-all&lt;/artifactId&gt; &lt;version&gt;1.9.5&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt;&lt;/dependency&gt; 2. CURD Spring MVC 业务代码（略） 3. 基于 Mockito 的单元测试基类 一般使用项目中已经写好的测试基类即可。 123456789101112131415161718192021222324252627282930313233343536373839404142@RunWith(SpringJUnit4ClassRunner.class)//表示整合JUnit4进行测试@ContextConfiguration(locations=&#123; \"classpath:spring/applicationContext.xml\", \"classpath:spring/applicationContext-persistent.xml\"&#125;)//加载spring配置文件public class BaseSpringTest &#123; private Gson gson = new GsonBuilder().setPrettyPrinting().create(); /** * 控制台打印展示对象 Json 字符串信息 */ public void printlnJson(Object object) &#123; System.out.println(gson.toJson(object)); &#125; @Autowired private UserService userService; /** * 设置上下文登录用户数据 */ public LoginUser mockLoginUser(String userId)&#123; LoginUser loginUser = new LoginUser(); UserBaseV userBaseV = userService.queryOne(userId); User user = new User(); BeanUtil.copyProperties(user, userBaseV); // 绑定指定用户 UserUtil.currentUser.set(user); PreconditionsUtil.checkNotNull(userBaseV, \"查询失败, 未查询到对应的用户数据\"); loginUser.setId(userBaseV.getId()); loginUser.setLoginName(userBaseV.getUsername()); loginUser.setDealerId(userBaseV.getDealerId()); loginUser.setOrgId(userBaseV.getOrganizationId()); loginUser.setUserName(userBaseV.getName()); return loginUser; &#125;&#125; 4. Service 对应的 Mockito 测试类 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162import com.google.common.collect.Lists;import com.google.gson.Gson;import org.junit.Before;import org.junit.Test;import org.mockito.InjectMocks;import org.mockito.Mock;import org.mockito.MockitoAnnotations;import org.springframework.beans.factory.annotation.Autowired;import java.util.List;import static org.mockito.Mockito.doReturn;import static org.mockito.Mockito.mock;/** * demo */public class MockitoBusinessTypeTest extends BaseMockitoSpringTest &#123; @InjectMocks private BusinessTypeService businessTypeService = mock(BusinessTypeService.class); @Mock private IvrDealerSettingService ivrDealerSettingService; /** * 上边使用 InjectMocks 注释的类，里面如果有依赖到的 service 可以通过下面的方法， * Mock 注解，会自动为上边那个类注入下面这个service */ @Mock private LOVService lovService; @Autowired private SeatService seatService; @Before public void initMock()&#123; MockitoAnnotations.initMocks(this); doReturn(Lists.newArrayList()).when(businessTypeService).getSatisfactionBusinessType(); doReturn(\"hello world\").when(ivrDealerSettingService).getSkillGroupByDealerAndIvrKey(\"a\", \"b\", \"c\"); BusinessTypeV businessTypeResult = new BusinessTypeV(); businessTypeResult.setCode(\"11\"); doReturn(businessTypeResult).when(businessTypeService).getUserDefaultBusinessType(\"system\"); &#125; @Test public void queryTest()&#123; List&lt;BusinessTypeLOV&gt; list = businessTypeService.getSatisfactionBusinessType(); String ivrResult = ivrDealerSettingService.getSkillGroupByDealerAndIvrKey(\"a\", \"b\", \"c\"); System.out.println(new Gson().toJson(list)); System.out.println(ivrResult); &#125; /** * mock with autowired */ @Test public void seatQueryTest()&#123; String businessType = businessTypeService.getUserDefaultBusinessType(\"system\").getCode(); // 结果是可以正常执行的 printlnJson(seatService.selectByBusinessType(businessType)); &#125;&#125; 5. Controller 对应的 Mockito 测试类 12345678910111213141516171819202122232425262728293031323334353637/** * Controller 测试类 */@RunWith(MockitoJUnitRunner.class)public class MockitoBusinessTypeControllerTest &#123; private MockMvc mockMvc; @InjectMocks private BusinessTypeController businessTypeController; @Mock private BusinessTypeService businessTypeService; @Mock private ClusterMessageListener clusterMessageListener; @Before public void initMock() &#123; MockitoAnnotations.initMocks(this); mockMvc = MockMvcBuilders.standaloneSetup(businessTypeController).build(); &#125; @Test public void getBusinessInfoTest() throws Exception &#123; // mock Service 方法行为 BusinessTypeV entity = new BusinessTypeV(); entity.setCode(\"11\"); when(businessTypeService.queryOne(Mockito.any())).thenReturn(entity); // 模拟接口调用 mockMvc.perform(get(\"/rest/businessType/all/getBusinessInfo\") .param(\"businessType\", \"11\") ) .andDo(print()) .andExpect(status().isOk()); &#125;&#125; 6. 注解的说明 首先是Spring的几个Annotate： RunWith(SpringJUnit4ClassRunner.class): 表示使用Spring Test组件进行单元测试; WebAppConfiguration: 使用这个Annotate会在跑单元测试的时候真实的启一个web服务，然后开始调用Controller的Rest API，待单元测试跑完之后再将web服务停掉; ContextConfiguration: 指定Bean的配置文件信息，可以有多种方式，这个例子使用的是文件路径形式，如果有多个配置文件，可以将括号中的信息配置为一个字符串数组来表示; 然后是Mockito的Annotate： Mock: 如果该对象需要mock，则加上此Annotate; InjectMocks: 使mock对象的使用类可以注入mock对象，在上面这个例子中，mock对象是UserService，使用了UserService的是UserController，所以在Controller加上该Annotate; Setup方法： MockitoAnnotations.initMocks(this): 将打上Mockito标签的对象起作用，使得Mock的类被Mock，使用了Mock对象的类自动与Mock对象关联。 mockMvc: 细心的朋友应该注意到了这个对象，这个对象是Controller单元测试的关键，它的初始化也是在setup方法里面。 测试用例： mockMvc.perform: 发起一个http请求。 post(url): 表示一个post请求，url对应的是Controller中被测方法的Rest url。 param(key, value): 表示一个request parameter，方法参数是key和value。 andDo（print()）: 表示打印出request和response的详细信息，便于调试。 andExpect（status().isOk()）: 表示期望返回的Response Status是200。 andExpect（content().string(is（expectstring））: 表示期望返回的Response Body内容是期望的字符串。 三、额外 Java 单元测试 PowerMock文章对 PowerMock 做了非常详尽的讲解，非常推荐。PowerMock也是依赖 Mockito，所以我认为这两个框架用起来的差别应该不大。","tags":[{"name":"Java","slug":"Java","permalink":"http://tech.noexception.cn/tags/Java/"},{"name":"测试","slug":"测试","permalink":"http://tech.noexception.cn/tags/%E6%B5%8B%E8%AF%95/"}]},{"title":"日志中心——Loki","date":"2022-06-03T03:37:30.000Z","path":"2022/06/03/log-center-loki/","text":"Docker Swarm 速通 Docker Swarm 结合 Loki 搭建轻量级日志监控系统","tags":[{"name":"Log","slug":"Log","permalink":"http://tech.noexception.cn/tags/Log/"},{"name":"Docker Swarm","slug":"Docker-Swarm","permalink":"http://tech.noexception.cn/tags/Docker-Swarm/"}]},{"title":"MapStruct 实践","date":"2022-05-22T03:06:31.000Z","path":"2022/05/22/learn-in-mapstruct/","text":"不做无用功 一、背景 开发过程中遇到的痛点问题： 来源类与目标类字段名不一致，举例具体表现为：将电商报名客户的信息，更新到商机客人时，会出现来源的客户号码属性名为: customerPhone，而目标的客户号码属性为：phone等等。 在某些跨库查询的需求中，需要聚合大家居库以及服务平台库中的两个业务实体的数据，查询并返回某个客户号码的沟通记录，并且要求带上此客户对应的意向潜客信息，即：查询接口返回的 VO 对象，需要返回服务平台的沟通记录，以及大家居系统的意向潜客信息，并且组合起来返回。 在生产编码过程中，基于安全原则，我们不能将我们数据库字段毫无保留的所有都返回给接口调用方，会约定相应的返回类以及收参类。 因此，在整个过程中，或多或少的，会有属性复制的操作，而在我们项目中，用的较多的是 Apache 提供的工具类：org.apache.commons.beanutils.BeanUtils.copyProperties(Object dest, Object orig) 方法来复制属性； 网上有许多公开资料显示，Apache 提供的 BeanUtils 工具类，存在严重的性能问题，参考图例： 纵坐标是对应操作次数的耗时，横坐标是不同拷贝类属性方法的工具。 可以看出最省事的做法就是，将原有的org.apache.commons.beanutils.BeanUtils.copyProperties 替换为 org.springframework.beans.BeanUtils.copyProperties，Spring 所提供的 BeanUtils 工具类。 但是执行效率，以及代码可调试性、可读性最高的依然还是原生的getter/setter方法。 二、MapStruct 之前 MapStruct 是一款专门用来处理 domain 实体类与 Model 类的属性映射的插件，我们只需要定义 Mapper 接口，MapStruct 就会在编译时自动的实现这个映射接口，避免麻烦复杂的映射实现。 MapStruct is a Java annotation processor for the generation of type-safe and performant mappers for Java bean classes. It saves you from writing mapping code by hand, which is a tedious and error-prone task. The generator comes with sensible defaults and many built-in type conversions, but it steps out of your way when it comes to configuring or implementing special behavior. 在编译时 MapStruct 将生成此接口的实现。 生成的实现使用纯 Java 方法调用来映射源对象和目标对象，即不涉及反射。 默认情况下，如果属性在来源类和目标类中具有相同的名称，则它们会被映射，也可以使用 @Mapping 和一些其他注释来自定义映射关系。 三、功能点介绍 对比其他属性映射框架的优势： 执行效率高: 使用在编译时生成的原生get/set方法，而不是使用反射的方法来实现； 编译时类型安全: 只能映射相互映射的对象和属性； 自我完备: 没有外部依赖 项目构建时，能够及时报告错误的映射关系。 简单且可调试 开发环境要求： Java 1.8+ 四、项目实践 1. 引入依赖 如果是基于 Maven 的项目，在 pom.xml 文件中添加： 12345678910111213141516171819202122232425262728293031323334353637383940...&lt;properties&gt; &lt;org.mapstruct.version&gt;1.4.2.Final&lt;/org.mapstruct.version&gt;&lt;/properties&gt;...&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.mapstruct&lt;/groupId&gt; &lt;artifactId&gt;mapstruct&lt;/artifactId&gt; &lt;version&gt;$&#123;org.mapstruct.version&#125;&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt;...&lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt; &lt;version&gt;3.8.1&lt;/version&gt; &lt;configuration&gt; &lt;source&gt;1.8&lt;/source&gt; &lt;target&gt;1.8&lt;/target&gt; &lt;annotationProcessorPaths&gt; &lt;path&gt; &lt;groupId&gt;org.mapstruct&lt;/groupId&gt; &lt;artifactId&gt;mapstruct-processor&lt;/artifactId&gt; &lt;version&gt;$&#123;org.mapstruct.version&#125;&lt;/version&gt; &lt;/path&gt; &lt;/annotationProcessorPaths&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt;&lt;/build&gt;... 如果是基于 Gradle 的项目，则需要在项目的 build.gradle 文件中添加： 12345678910111213plugins &#123; ... id \"com.diffplug.eclipse.apt\" version \"3.26.0\" // Only for Eclipse&#125;dependencies &#123; ... compile 'org.mapstruct:mapstruct:1.4.2.Final' annotationProcessor 'org.mapstruct:mapstruct-processor:1.4.2.Final' testAnnotationProcessor 'org.mapstruct:mapstruct-processor:1.4.2.Final' // if you are using mapstruct in test code&#125;... 2. 示例 (1) 简单的映射关系 假设我们有一个来源类：新电商客户——NewCustomer，继承自基类——BaseBO 12345678910111213// BaseBO.java@Data // Lombok注解public class BaseBO implements Serializable &#123; private static final long serialVersionUID = -1; private String id;// Id private String createdBy; // 创建人Id private Date createdTime; //创建日期 private Date lastUpdateTime;//最后更新时间 private String lastUpdatedBy;//最后更新人Id private Integer rowVersion;//更新次数&#125; 123456789101112131415// NewCustomer.java@Data // Lombok注解public class NewCustomer extends BaseBO &#123; private String customerName;// 客户姓名 private String customerPhone;// 客户电话 private String followCustomerServiceName;//跟进客服姓名 private String dealerStatus; // 经销商状态 private String dealerName; // 经销商名称 private String cusJobStatus;//客服是否在职 private String createdUserName; // 创建人名称 private String groupName;// 技能组名称 private String lastupdaterName;// 最后更新人名称 private String shopName; // 门店名称 private String guideName; // 导购姓名&#125; 假设我们有一个目标类：虚拟客户VO——VirtualCustomerVO 1234567891011121314151617181920// VirtualCustomerVO.java@Datapublic class VirtualCustomerVO &#123; // 虚拟客户ID private String id; // 客户姓名 private String customerName; // 客户电话 private String customerPhone; // 跟进客服姓名 private String followCustomerServiceName; // 创建人ID private String createdBy; // 创建人姓名 private String createdUserName; // 创建时间 private Date createdTime; // 最后更新时间 private Date lastUpdateTime;&#125; 定义映射接口： 12345678910111213141516171819202122232425262728293031// IMapping.java 公共对象映射接口@MapperConfigpublic interface IMapping&lt;SOURCE, TARGET&gt;&#123; /** * 映射同名属性 */ TARGET sourceToTarget(SOURCE var1); /** * 反向，映射同名属性 */ @InheritInverseConfiguration(name = \"sourceToTarget\") SOURCE targetToSource(TARGET var1); /** * 映射同名属性，集合形式 */ @InheritConfiguration(name = \"sourceToTarget\") List&lt;TARGET&gt; sourceToTarget(List&lt;SOURCE&gt; var1); /** * 反向，映射同名属性，集合形式 */ @InheritConfiguration(name = \"targetToSource\") List&lt;SOURCE&gt; targetToSource(List&lt;TARGET&gt; var1); /** * 映射同名属性，集合流形式 */ List&lt;TARGET&gt; sourceToTarget(Stream&lt;SOURCE&gt; stream); /** * 反向，映射同名属性，集合流形式 */ List&lt;SOURCE&gt; targetToSource(Stream&lt;TARGET&gt; stream);&#125; 123456// NewCustomer 与 VirtualCustomerVO 映射关系接口@Mapper(componentModel = \"default\", unmappedSourcePolicy = ReportingPolicy.IGNORE, unmappedTargetPolicy = ReportingPolicy.IGNORE)public interface VirtualCustomerMapping extends IMapping&lt;NewCustomer, VirtualCustomerVO&gt; &#123; IMapping&lt;NewCustomer, VirtualCustomerVO&gt; INSTANCE = Mappers.getMapper(VirtualCustomerMapping.class);&#125; Marks an interface or abstract class as a mapper and activates the generation of a implementation of that type via MapStruct. @Mapper : 将接口类或抽象类标记为由 MapStruct 来实现的映射类。 测试验证： 123456789101112131415161718192021222324252627282930313233343536// NewCustomerServiceTest.javapublic class NewCustomerServiceTest&#123; private NewCustomer mockSourceData()&#123; NewCustomer sourceEntity = new NewCustomer(); sourceEntity.setId(UUID.fastUUID().toString(true)); sourceEntity.setCreatedBy(\"lvtao\"); sourceEntity.setCreatedTime(new Date()); sourceEntity.setLastUpdateTime(new Date()); sourceEntity.setLastUpdatedBy(\"lvtao1\"); sourceEntity.setRowVersion(1); sourceEntity.setCustomerName(\"感冒灵\"); sourceEntity.setCustomerPhone(\"13888888888\"); sourceEntity.setFollowCustomerServiceName(\"张三\"); sourceEntity.setDealerStatus(\"有效\"); sourceEntity.setDealerName(\"广州索菲亚\"); sourceEntity.setCusJobStatus(\"在职\"); sourceEntity.setCreatedUserName(\"李四\"); sourceEntity.setGroupName(\"广州售后组\"); sourceEntity.setLastupdaterName(\"王五\"); sourceEntity.setShopName(\"索菲亚正佳店\"); sourceEntity.setGuideName(\"导购老王\"); return sourceEntity; &#125; @Test public void testMapping() &#123; NewCustomer source = mockSourceData(); System.out.println(\"source: \"); System.out.println(JsonUtils.toJson(source)); VirtualCustomerVO target = VirtualCustomerMapping.INSTANCE.sourceToTarget(source); System.out.println(\"target: \"); System.out.println(JsonUtils.toJson(target)); &#125;&#125; 测试结果 12345678910111213141516171819202122232425262728293031source: &#123; \"id\": \"75c159f307624d5293c90ba3551aacb1\", \"createdBy\": \"lvtao\", \"createdTime\": \"2022-06-01 16:05:34\", \"lastUpdateTime\": \"2022-06-01 16:05:34\", \"lastUpdatedBy\": \"lvtao1\", \"rowVersion\": 1, \"customerName\": \"感冒灵\", \"customerPhone\": \"13888888888\", \"followCustomerServiceName\": \"张三\", \"dealerStatus\": \"有效\", \"dealerName\": \"广州索菲亚\", \"cusJobStatus\": \"在职\", \"createdUserName\": \"李四\", \"groupName\": \"广州售后组\", \"lastupdaterName\": \"王五\", \"shopName\": \"索菲亚正佳店\", \"guideName\": \"导购老王\"&#125;target: &#123; \"id\": \"75c159f307624d5293c90ba3551aacb1\", \"customerName\": \"感冒灵\", \"customerPhone\": \"13888888888\", \"followCustomerServiceName\": \"张三\", \"createdBy\": \"lvtao\", \"createdUserName\": \"李四\", \"createdTime\": \"2022-06-01 16:05:34\", \"lastUpdateTime\": \"2022-06-01 16:05:34\"&#125; (2) 不同成员属性名称的映射关系 有些时候，有些需求，需要查询几个不同业务库的数据，返回接口调用方，比如说，“客人姓名”字段，在来源类中定义的可能是 customerName，而在目标类中定义的可能是 cusName，这种情况在业务需求开发过程中是非常常见的。 实现方式： 12345678910// NewCustomer 与 VirtualCustomerVO 映射关系接口@Mapper(componentModel = \"default\", unmappedSourcePolicy = ReportingPolicy.IGNORE, unmappedTargetPolicy = ReportingPolicy.IGNORE)public interface VirtualCustomerMapping extends IMapping&lt;NewCustomer, VirtualCustomerVO&gt; &#123; IMapping&lt;NewCustomer, VirtualCustomerVO&gt; INSTANCE = Mappers.getMapper(VirtualCustomerMapping.class); @Override @Mapping(source = \"customerName\", target = \"cusName\") VirtualCustomerVO sourceToTarget(NewCustomer source);&#125; 测试验证： 123456789101112131415161718192021// NewCustomerServiceTest.javapublic class NewCustomerServiceTest&#123; private NewCustomer mockSourceData()&#123; ... sourceEntity.setCustomerName(\"感冒灵\"); ... return sourceEntity; &#125; @Test public void testMapping() &#123; NewCustomer source = mockSourceData(); System.out.println(\"source: \"); System.out.println(JsonUtils.toJson(source)); VirtualCustomerVO target = VirtualCustomerMapping.INSTANCE.sourceToTarget(source); System.out.println(\"target: \"); System.out.println(JsonUtils.toJson(target)); &#125;&#125; 测试结果： 123456789101112131415161718192021222324252627282930source: &#123; \"id\": \"eed438f1370b4a43bef4642b8772de85\", \"createdBy\": \"lvtao\", \"createdTime\": \"2022-06-01 17:50:52\", \"lastUpdateTime\": \"2022-06-01 17:50:52\", \"lastUpdatedBy\": \"lvtao1\", \"rowVersion\": 1, \"customerName\": \"感冒灵\", \"customerPhone\": \"13888888888\", \"followCustomerServiceName\": \"张三\", \"dealerStatus\": \"有效\", \"dealerName\": \"广州索菲亚\", \"cusJobStatus\": \"在职\", \"createdUserName\": \"李四\", \"groupName\": \"广州售后组\", \"lastupdaterName\": \"王五\", \"shopName\": \"索菲亚正佳店\", \"guideName\": \"导购老王\"&#125;target: &#123; \"id\": \"eed438f1370b4a43bef4642b8772de85\", \"cusName\": \"感冒灵\", \"customerPhone\": \"13888888888\", \"followCustomerServiceName\": \"张三\", \"createdBy\": \"lvtao\", \"createdUserName\": \"李四\", \"createdTime\": \"2022-06-01 17:50:52\", \"lastUpdateTime\": \"2022-06-01 17:50:52\"&#125; (3) 聚合多个来源类到一个目标类中 有种情况，目标类的属性由两个不同的来源类组成，这种情况 MapStruct 也能轻松完成； 例如我们有一个客户扩展类——NewCustomerExt，里面的属性有 age、sex、address: 12345678910// NewCustomerExt.java 客户扩展类@Datapublic class NewCustomerExt &#123; // 客户年龄 private Integer age; // 客户性别 private String sex; // 客户住址 private String address;&#125; 修改目标类： 1234567891011// VirtualCustomerVO.java@Datapublic class VirtualCustomerVO &#123; ... // 客户年龄 private Integer age; // 客户性别 private String sex; // 客户住址 private String address;&#125; 修改映射接口 1234567891011@Mapper(componentModel = \"spring\", unmappedTargetPolicy = ReportingPolicy.IGNORE, unmappedSourcePolicy = ReportingPolicy.IGNORE)public interface VirtualCustomerMapping extends IMapping&lt;NewCustomer, VirtualCustomerVO&gt; &#123; VirtualCustomerMapping INSTANCE = Mappers.getMapper(VirtualCustomerMapping.class); @Override @Mapping(source = \"customerName\", target = \"cusName\") VirtualCustomerVO sourceToTarget(NewCustomer var1); @Mapping(source = \"var1.customerName\", target = \"cusName\") VirtualCustomerVO multiSourceToTarget(NewCustomer var1, NewCustomerExt var2);&#125; 测试验证 123456789101112131415161718public class NewCustomerServiceTest &#123; ... @Test public void testMultiMapping()&#123; NewCustomer source = mockSourceData(); NewCustomerExt sourceExt = new NewCustomerExt(); sourceExt.setAddress(\"广州市天河区体育东路108号\"); sourceExt.setAge(18); sourceExt.setSex(\"男\"); VirtualCustomerVO target = VirtualCustomerMapping.instance.multiSourceToTarget(source, sourceExt); System.out.println(\"source: \"); System.out.println(JsonUtils.toJson(source)); System.out.println(\"sourceExt: \"); System.out.println(JsonUtils.toJson(sourceExt)); System.out.println(\"target: \"); System.out.println(JsonUtils.toJson(target)); &#125;&#125; 测试结果 12345678910111213141516171819202122232425262728293031323334353637383940source: &#123; \"id\": \"6509ce8263a044b49d9d0804a249a041\", \"createdBy\": \"lvtao\", \"createdTime\": \"2022-06-01 18:19:41\", \"lastUpdateTime\": \"2022-06-01 18:19:41\", \"lastUpdatedBy\": \"lvtao1\", \"rowVersion\": 1, \"customerName\": \"感冒灵\", \"customerPhone\": \"13888888888\", \"followCustomerServiceName\": \"张三\", \"dealerStatus\": \"有效\", \"dealerName\": \"广州索菲亚\", \"cusJobStatus\": \"在职\", \"createdUserName\": \"李四\", \"groupName\": \"广州售后组\", \"lastupdaterName\": \"王五\", \"shopName\": \"索菲亚正佳店\", \"guideName\": \"导购老王\"&#125;sourceExt: &#123; \"age\": 18, \"sex\": \"男\", \"address\": \"广州市天河区体育东路108号\"&#125;target: &#123; \"id\": \"6509ce8263a044b49d9d0804a249a041\", \"cusName\": \"感冒灵\", \"customerPhone\": \"13888888888\", \"followCustomerServiceName\": \"张三\", \"createdBy\": \"lvtao\", \"createdUserName\": \"李四\", \"createdTime\": \"2022-06-01 18:19:41\", \"lastUpdateTime\": \"2022-06-01 18:19:41\", \"age\": 18, \"sex\": \"男\", \"address\": \"广州市天河区体育东路108号\"&#125; (4) 映射类型格式化 MapStruct 支持来源类和目标类之间的数据类型转换。它还提供了基本类型及响应的包装类型之间的自动转换。 从 int 到 String 的转换: 123456789// 来自官方示例：@Mapperpublic interface CarMapper&#123; @Mapping(source = \"price\", numberFormat = \"$#.00\") CarDto carToCarDto(Car car); @IterableMapping(numberFormat = \"$#.00\") List&lt;String&gt; prices(List&lt;Integer&gt; prices);&#125; 从 BigDecimal 到 String 的转换: 1234567// 来自官方示例@Mapperpublic interface CarMapper&#123; // 科学计数法，例如: 有数字: 10086, 格式化以后就是: 10.09E3 (=&gt; 10.09 * 10^3) @Mapping(source = \"power\", numberFormat = \"#.##E0\") CarDto carToCarDto(Car car);&#125; 从日期类型到字符串的转换: 123456789// 来自官方示例@Mapperpublic interface CarMapper &#123; @Mapping(source = \"manufacturingDate\", dateFormat = \"dd.MM.yyyy\") CarDto carToCarDto(Car car); @IterableMapping(dateFormat = \"dd.MM.yyyy\") List&lt;String&gt; stringListToDateList(List&lt;Date&gt; dates);&#125; (5) 集合、Stream映射 集合类型的映射与映射 Bean 类型的方式相同，即通过在映射器接口中定义来源类和目标类的映射方法。MapStruct 支持 Java 集合框架中的各种可迭代类型。 生成的代码将包含一个循环，该循环遍历来源集合，把每一个元素转换后放入目标集合中。如果在给定的映射器或其使用的映射器中找到集合元素类型的映射方法，则调用此方法来执行元素转换。 示例： 12345678// 如果我们的映射器接口是继承自 IMapping.java 接口类的话，可以直接调用方法sourceToTarget() 例如： @Test public void testCollectionMapping()&#123; List&lt;NewCustomer&gt; sourceList = Lists.newArrayList(); List&lt;VirtualCustomerVO&gt; targetList = Lists.newArrayList(); targetList = VirtualCustomerMapping.INSTANCE.sourceToTarget(sourceList); List&lt;VirtualCustomerVO&gt; virtualCustomerVOS = VirtualCustomerMapping.INSTANCE.sourceToTarget(sourceList.stream()); &#125; 五、总结 MapStruct 是一个用于创建映射器的库，从基本映射到自定义方法和自定义映射器，此外， 我们还介绍了MapStruct提供的一些高级操作选项，包括依赖注入，数据类型映射和表达式使用。 执行效率高，接近原生的 get/set 方法的执行效率； 参考资料 [1]MapStruct Reference Guide","tags":[{"name":"Java","slug":"Java","permalink":"http://tech.noexception.cn/tags/Java/"}]},{"title":"《从零开始写 Canvas 引擎》——极坐标系作业","date":"2022-05-21T05:23:56.000Z","path":"2022/05/21/start-write-canvas-engine/","text":"沉淀 效果图： 源码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;title&gt;Line Basic&lt;/title&gt; &lt;meta name=\"viewport\" content=\"initial-scale=1, maximum-scale=1, user-scalable=no\"&gt; &lt;meta name=\"apple-mobile-web-app-capable\" content=\"yes\"&gt; &lt;meta name=\"apple-mobile-web-app-status-bar-style\" content=\"black\"&gt; &lt;meta charset=\"utf-8\"&gt; &lt;style&gt; html, body &#123; height: 100%; &#125; body &#123; margin: 0; padding: 0; background-color: rgb(42, 42, 42); &#125; &lt;/style&gt; &lt;body&gt; &lt;canvas id=\"canvas-1\" width=\"1024\" height=\"768\" style=\"background-color: antiquewhite;margin:30px;\"&gt;&lt;/canvas&gt; &lt;/body&gt; &lt;script&gt; let canvas = document.getElementById('canvas-1'); let context = canvas.getContext('2d'); let width = canvas.width; let height = canvas.height; let origin = [width/2, height/2]; let x1 = origin[0]+100; let y1 = origin[1]+40; let x2 = origin[0] + 140; let y2 = origin[1] + 120; //计算线段相对于极轴的旋转角，返回弧度 function calcRadian(x1,y1,x2,y2)&#123; let radian = Math.atan2(y2-y1,x2-x1); return radian; &#125; //计算两个蓝色点的坐标 function calcPoints(x,y,len,lineRadian,arrowRadian)&#123; let x1=len*Math.cos(lineRadian+arrowRadian); let y1=len*Math.sin(lineRadian+arrowRadian); let x2=len*Math.cos(lineRadian-arrowRadian); let y2=len*Math.sin(lineRadian-arrowRadian); return [[x1+x,y1+y],[x2+x,y2+y]]; &#125; // 计算画出来的连线相对于极轴的旋转角度 // let lineRadian = Math.atan2(y2 - y1, x2 - x1); // 调用atan2(起点y-终点y, 起点x-终点x) let lineRadian = calcRadian(x2,y2,x1,y1); // 箭头二分之一的夹角, PI/4 应该是一个等腰直角三角形 let rowRadian = Math.PI/4; // 首先计算点(x1, y1)附近的两个三角形的点 // 1. +rowRadian, len: 三角形腰长 let len=20; // let x1_1 = len*Math.cos(lineRadian + rowRadian)+x2; // let y1_1 = len*Math.sin(lineRadian + rowRadian)+y2; // let x1_2 = len*Math.cos(lineRadian - rowRadian)+x2; // let y1_2 = len*Math.sin(lineRadian - rowRadian)+y2; let points = calcPoints(x2, y2, len, lineRadian, rowRadian); // 画出线条 context.moveTo(x1, y1); context.lineTo(x2, y2); context.stroke(); // context.lineTo(x1_1, y1_1); context.lineTo(points[0][0], points[0][1]); context.stroke(); // context.lineTo(x1_2, y1_2); context.lineTo(points[1][0], points[1][1]); context.stroke(); context.lineTo(x2, y2); context.stroke(); context.fill(); // 画出第二个箭头 // 计算【最初的起点】与极轴的夹角, 此时起始点与终点对调了 let startLineRadian = calcRadian(x2,y2,x1,y1); // -Math.PI 旋转180°？ let startPoints = calcPoints(x1, y1, len, startLineRadian-Math.PI, rowRadian); context.lineTo(x1, y1); context.lineTo(startPoints[0][0], startPoints[0][1]); context.lineTo(startPoints[1][0], startPoints[1][1]); context.lineTo(x1, y1); context.stroke(); context.fill(); &lt;/script&gt;&lt;/html&gt;","tags":[{"name":"canvas","slug":"canvas","permalink":"http://tech.noexception.cn/tags/canvas/"}]},{"title":"二级域名以及 Docker 容器互相访问","date":"2022-04-08T08:27:18.000Z","path":"2022/04/08/subdomain/","text":"二级域名 起因 由于在一台服务器上部署了多个不同的应用/服务，之前是使用域名+端口号的方式来区分应用。但是这种方式在应用或服务多了以后，就不好使了，对于个人来说，需要记上应用或服务对应的端口号以及服务的域名后缀。 于是就有了这篇文章记录。 在 Nginx 配置子域名 在 Nginx 中配置需要的子域名（我习惯将每一个子域名的配置分开来，一个子域名对应一个字配置文件） 在 Nginx 默认配置文件 http 节点下配置：include /path/to/config/*.conf Portainer 配置： 123456789101112131415# portainer.confserver &#123; listen 80; listen [::]:80; server_name docker.noexception.cn; location / &#123; proxy_redirect off; proxy_set_header host $host; proxy_set_header x-real-ip $remote_addr; proxy_set_header x-forwarded-for $proxy_add_x_forwarded_for; proxy_pass http://portainer:9000/; &#125;&#125; 定时任务配置： 1234567891011121314151617181920212223# tasks.confserver &#123; listen 80; listen [::]:80; server_name tasks.noexception.cn; location ^~ /xxl-job-admin &#123; proxy_redirect off; proxy_set_header host $host; proxy_set_header x-real-ip $remote_addr; proxy_set_header x-forwarded-for $proxy_add_x_forwarded_for; proxy_pass http://xxl-job-admin:7397/xxl-job-admin/; &#125; location / &#123; proxy_redirect off; proxy_set_header host $host; proxy_set_header x-real-ip $remote_addr; proxy_set_header x-forwarded-for $proxy_add_x_forwarded_for; proxy_pass http://xxl-job-admin:7397/xxl-job-admin/; &#125;&#125; 配置域名解析 在域名管理界面中，添加一条解析记录： 记录类型为A， 主机记录为: 子域名（如：docker）， 记录值为服务器的IP地址， 提交保存。 总结 整个配置过程并不复杂，概况来说就是三步： 部署应用； 添加 Nginx 配置（如 portainer.conf）； 在域名解析页面中，添加子域名的解析记录。 补充： 1. 关于在 Docker 中，配置好子域名后，发现无法访问的情况。 原因： 是因为 docker 的网络策略默认情况下，容器与容器之间是无法相互访问的，在启动容器的时候，得给她们指定好网络组。 又因为容器重启，IP 会随之变化，所以我们需要利用 docker 网络，通过容器 name 在容器中互相访问。 Docker 网络 1. 创建自定义网络 指令: docker network create domain 默认使用的是 bridge 驱动 不在同一个 docker network 中的容器，不能互相访问，他们不在同一个网段上 2. 创建容器时，指定 docker network 启动第一个容器，指令: docker run -it --name portainer --network domain -p 9000:9000 portainer/portainer --network 参数指定容器使用的网络 启动第二个容器，指令: docker run -p 6379:6379 --network domain --name redis -v /docker/data/redis/redis.conf:/etc/redis/redis.conf -v /docker/data/redis/data:/data -d redis redis-server /etc/redis/redis.conf --appendonly yes 启动一个 redis 服务容器，通过在 redis 容器访问 portainer 容器，使用 curl 工具来协助我们验证 验证： 使用docker exec进入 redis 容器中 123# docker exec -it redis bash[root@noexception ~]# docker exec -it redis bashroot@a01af1db7118:&#x2F;data# 使用 curl 工具进行验证： 12# curl http:&#x2F;&#x2F;portainer:9000# ping http:&#x2F;&#x2F;portainer:9000 使用 docker network inspect domain 来查看 docker network 信息，检查两个容器是否链接到了同一个网络下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273[ &#123; \"Name\": \"domain\", \"Id\": \"17a05973b0e8805b372e143d3a7ce591a076e98e3d7cb357444ed2ee1338e009\", \"Created\": \"2022-04-08T15:13:19.017550444+08:00\", \"Scope\": \"local\", \"Driver\": \"bridge\", \"EnableIPv6\": false, \"IPAM\": &#123; \"Driver\": \"default\", \"Options\": &#123;&#125;, \"Config\": [ &#123; \"Subnet\": \"172.18.0.0/16\", \"Gateway\": \"172.18.0.1\" &#125; ] &#125;, \"Internal\": false, \"Attachable\": false, \"Ingress\": false, \"ConfigFrom\": &#123; \"Network\": \"\" &#125;, \"ConfigOnly\": false, \"Containers\": &#123; \"11ccb85d3c61b0a5826d311965929b1dad07aec2013778bc7d4fbf46dbaace7c\": &#123; \"Name\": \"nginx\", \"EndpointID\": \"d0d611461ff9a3849e53c05c27fdf26ca39bea739d24de613b013b86cb8a43ff\", \"MacAddress\": \"02:42:ac:12:00:03\", \"IPv4Address\": \"172.18.0.3/16\", \"IPv6Address\": \"\" &#125;, \"7f2e31026a6249577632239f6cd69a6781718a6e4b436db5747fece6599b05ae\": &#123; \"Name\": \"zookeeper\", \"EndpointID\": \"38cbc10011c3e68ccbcf7f7c7b69948df0fd6a72834d10258752139e149efa0d\", \"MacAddress\": \"02:42:ac:12:00:05\", \"IPv4Address\": \"172.18.0.5/16\", \"IPv6Address\": \"\" &#125;, \"8e37d220283e84af7382a4481baea5f8dca61b30166922bd8bc03adfd2dbb322\": &#123; \"Name\": \"portainer\", \"EndpointID\": \"0f51d369c1fe824b0d3941d8a3dce868a88581a17733d4a685515401ea6b08a6\", \"MacAddress\": \"02:42:ac:12:00:02\", \"IPv4Address\": \"172.18.0.2/16\", \"IPv6Address\": \"\" &#125;, \"a01af1db711844c4547d2b64e53021f5bb6967fb7e83120592d5c913872f4cd9\": &#123; \"Name\": \"redis\", \"EndpointID\": \"1754b57297a8a7ea0933fcab19727b045c1948551ff1bdab449c2b4c525cda11\", \"MacAddress\": \"02:42:ac:12:00:04\", \"IPv4Address\": \"172.18.0.4/16\", \"IPv6Address\": \"\" &#125;, \"dc550ff519c39f9f9800e3ba5dc25ae4c435550d1259425caba426601a4dc358\": &#123; \"Name\": \"xxl-job-admin\", \"EndpointID\": \"6373e88cc3ce52fefbcbcb99fdccdd74df16c64c805a071e82cf07985675b8e7\", \"MacAddress\": \"02:42:ac:12:00:06\", \"IPv4Address\": \"172.18.0.6/16\", \"IPv6Address\": \"\" &#125;, \"f7762c952a1c21cbc230fe8c65c705bacafd57c9655744b2cc43af658dd945d7\": &#123; \"Name\": \"kafka\", \"EndpointID\": \"52ca42e07513833630f4906b34590641bbb743d9586eba9da08e9796a56fd147\", \"MacAddress\": \"02:42:ac:12:00:07\", \"IPv4Address\": \"172.18.0.7/16\", \"IPv6Address\": \"\" &#125; &#125;, \"Options\": &#123;&#125;, \"Labels\": &#123;&#125; &#125;]","tags":[{"name":"Docker","slug":"Docker","permalink":"http://tech.noexception.cn/tags/Docker/"},{"name":"Nginx","slug":"Nginx","permalink":"http://tech.noexception.cn/tags/Nginx/"}]},{"title":"2022 新年计划","date":"2022-01-17T06:54:46.000Z","path":"2022/01/17/2022-new-page/","text":"参不尽天下之理 2022 年需要完成的技术体系： Netty 网络框架及项目实践； 系统二级缓存框架； Idea 插件开发； 计划提升的技能点： 深入理解及实践设计模式和设计原则； 继续加强数据结构与算法，每周一练； 待提升的软技能： 提升沟通能力； 善于倾听，变得更 Considerate； 一年内，至少看完一本非技术类书籍； 第二技能的学习规划： 从 Solidity 入门区块链开发 了解区块链游戏开发","tags":[{"name":"计划","slug":"计划","permalink":"http://tech.noexception.cn/tags/%E8%AE%A1%E5%88%92/"}]},{"title":"每日总结打卡-2021/12/15","date":"2021-12-15T15:28:30.000Z","path":"2021/12/15/sign-20211215/","text":"见不尽天下之事 S情景 最近这段时间的内容主要是： 每天学习一节抽奖项目的内容，当前进度：第13节； 查找并学习如何实现一个二级缓存框架； 零碎的工作上的事情。 T任务 提交今天的 Lottery 项目学习代码作业 这两天找到了一个二级缓存的开源项目：J2Cache，clone 到本地 A行动 关于 Lottery 项目的作业，统一 push 到了当前项目目录下的 idea-plugin/mylottery 下，以一个 git submodule 的形式整理在当前这个仓库中。 把 J2Cache 源码 clone 到本地，通过官方的单元测试，进行单步调试，首先想了解下，大神写的二级缓存框架的主要流程大体上是怎么样的； 今晚下班的时候，顺带也去 star 了阿里家的 JetCache 也是一个二级缓存框架，本想查查这两个框架的差别，但是网上能够搜索到的资料相当有限。暂时先研究透 J2Cache 先吧，饭要一口一口吃，路要一步一步走。 R结果 关于 J2Cache 官方测试类代码调试，目前看到缓存的配置加载以及缓存的初始化流程。自从刷完傅哥的 《手撸Spring专栏》以后，看这些源码似乎没有以前那么吃力了，自己也很惊讶。坚持！ 日拱一卒，功不唐捐","tags":[{"name":"打卡","slug":"打卡","permalink":"http://tech.noexception.cn/tags/%E6%89%93%E5%8D%A1/"}]},{"title":"缓存框架设计思路","date":"2021-12-11T16:15:06.000Z","path":"2021/12/12/cache/","text":"读不尽天下之书 需要解决的问题点 1. 分布式缓存同步 问题： 在高并发的场景下，如何保证分布式场景下各个节点中本地缓存的一致性问题？ 解决思路： 同步的目的是为了尽可能保证分布式缓存的一致性。通过发布订阅功能来实现分布式缓存下不同节点的缓存同步。 数据变更通知 + 定期刷新过期缓存的策略，尽可能的保证缓存的一致性。可以通过Redis + Kafka的发布订阅功能实现。 框架留好扩展点，可以快速便捷的扩展其他 MQ 来实现缓存同步。 使用缓存，必定会存在不一致的情况，无法保证强一致性。 2. 缓存更新 问题： 缓存更新包含了本地缓存以及Redis的操作，同时通知其他缓存节点进行缓存更新操作； 解决思路： 主动更新 获取缓存时，若缓存不存在或缓存已过期，则重新加载缓存； 源数据变更后，调用缓存刷新接口重新加载缓存（此时只对已存在的 key 重新加载） 自动更新 定期刷新过期缓存，尽可能保证分布式缓存的一致性； 3. 缓存淘汰 问题： 通知其他缓存节点进行缓存淘汰 解决思路： 主动淘汰 获取缓存时，检查缓存是否过期，如果过期则淘汰缓存； 结合@CacheEvict在源数据修改前或修改后，淘汰缓存； 数据源变更后，调用刷新缓存接口，进行缓存淘汰； 自动淘汰 利用Redis的缓存淘汰策略管理 缓存淘汰算法 4. 缓存预热 问题： 解决思路： 手动预热 对标注了缓存注解的如@Cacheable或者@CachePut的业务接口进行缓存预热。 自动预热 在系统启动完毕后，调用业务接口将数据加载到缓存中。 5. 热点数据 问题： 缓存集群中的某个 key 瞬间被数万甚至十万的并发请求打爆 解决思路： 采用本地缓存来缓解缓存集群和数据库集群的压力。使用二级缓存的形式解决。 应用层面做限流熔断机制，保护后面的缓存集群和数据库集群可用。 6. 缓存雪崩 问题： 由于大量缓存失效，导致大量请求打到数据库上，导致数据库的 CPU 和内存压力变大，从而出现一系列连锁反应，造成整个系统崩溃。 解决思路： Caffeine 默认使用异步机制加载缓存数据，可有效防止缓存击穿（防止同一个 key 或不同 key 被击穿的场景） 将缓存层设计成高可用，防止缓存大面积故障 利用本地缓存，一定程度上保证服务的可用性。但主要还是通过对源服务的访问进行限流、熔断、降级等手段。 提前压测，项目上线前，演练缓存层宕机后，应用以及后端的负载情况以及可能出现的问题，对高可用提前预演，提前发现问题。 7. 缓存击穿 问题： 在平常高并发的系统中，大量的请求同时查询一个 key 时，此时这个 key 正好失效了，就会导致大量的请求都打到数据库上面去，这种现象就是缓存击穿 解决思路： 解决思路同缓存雪崩，利用Caffeine默认使用异步机制加载缓存数据，可以有效的防止缓存击穿。 8. 缓存穿透 问题： 请求根本不存在的数据，也就是在缓存和数据库中都查不到这条数据，但是请求每次都会打到数据库上面去。这种查询不存在数据的现象就是缓存穿透。 解决思路： 通过对不存在的 key 缓存空值，来防止缓存穿透。 也可以通过使用BloomFilter来对 key 进行过滤。 对于高并发系统，可以结合 Hystrix 或 Sentinel来做应用级别的限流和降级，以保护下游系统不会被大量的请求给打死。","tags":[{"name":"缓存设计","slug":"缓存设计","permalink":"http://tech.noexception.cn/tags/%E7%BC%93%E5%AD%98%E8%AE%BE%E8%AE%A1/"}]},{"title":"每日总结打卡-2021/12/10","date":"2021-12-10T15:59:47.000Z","path":"2021/12/10/sign-1210/","text":"日记跬步，可至千里 S-情景 项目脚手架的代码生成器已经开发完了，周五开坑，开始了解idea插件开发，计划先写一个提醒喝水的插件。多喝水，多上厕所，多走动走动，对身体好，哈哈哈。 其次就是后端脚手架项目，需要一个缓存模块，于是准备开坑，开始撸一个缓存中间件。 T-任务 IDEA-Plugin 章节，使用 Gradle 创建插件项目； 将插件项目 helloworld 跑通； 将缓存模块包装秤一个starter，在需要的项目中，引入pom依赖； A-行动 后端脚手架项目，代码生成工具已经撸完了； 使用 gradle 构建 Idea-Plugin 插件项目，并跑通 Helloworld； 后续把作业项目同步上传至 https://codechina.csdn.net/CreativeAlliance/lottery-102-999.git","tags":[{"name":"打卡","slug":"打卡","permalink":"http://tech.noexception.cn/tags/%E6%89%93%E5%8D%A1/"}]},{"title":"2021年的第一篇总结","date":"2021-11-27T14:00:46.000Z","path":"2021/11/27/202111summary/","text":"温故而知新 做了什么 完成《手撸 Spring 专栏》container-mini； 开始尝试基于Spring开发中间件，如：服务限流器、缓存中间件； 在项目中引入drools规则引擎； 编写了一个 CURD 代码生成的小工具*fast-code*； 没完成的事 每周算法打卡计划总是断断续续…😔 梳理 Java 后端技术栈知识未完成； 下一步计划 …","tags":[{"name":"总结","slug":"总结","permalink":"http://tech.noexception.cn/tags/%E6%80%BB%E7%BB%93/"}]},{"title":"以 Spring MVC 模式编写 MongoDB 的 CURD","date":"2021-08-01T07:47:48.000Z","path":"2021/08/01/mongo-spring-mvc/","text":"日拱一卒，功不唐捐。 一、MongoDB 介绍 MongoDB 是文档数据库，NoSQL数据库中的一种，本篇文章，分享使用Spring MVC的方式去编写MongoDB的CURD操作代码，简化问价存储的开发流程。 二、具体操作 A. 小文件存储 引入MongoDB依赖： 123456789101112131415161718&lt;！-- SpringBoot 用户 --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-mongodb&lt;/artifactId&gt;&lt;/dependency&gt; &lt;！-- 非 SpringBoot 用户 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.mongodb&lt;/groupId&gt; &lt;artifactId&gt;mongodb-driver-sync&lt;/artifactId&gt; &lt;version&gt;4.1.1&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.data&lt;/groupId&gt; &lt;artifactId&gt;spring-data-mongodb&lt;/artifactId&gt; &lt;version&gt;3.1.5&lt;/version&gt; &lt;/dependency&gt; 编写Entity代码： 123456789101112131415161718@Data@Document // 指定对应的 collection 的名称public class TemplateDocument implements Serializable &#123; private static final long serialVersionUID = 5701973075364468575L; @Id // 文档主键ID private String id; // 定义文档属性 private String name; /** * 二进制文件内容 * */ @JsonIgnore private Binary content;&#125; 编写持久层代码： 12345678public interface TemplateDao extends MongoRepository&lt;TemplateDocument, String&gt; &#123; /** * 根据文件名称查询 */ @Query(\"&#123;'name':?0&#125;\") List&lt;TemplateDocument&gt; findByName(String fileName);&#125; 编写服务层代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748@Servicepublic class TemplateService &#123; @Autowired private TemplateDao templateDao; /** * 查询文档 */ public List&lt;TemplateDocument&gt; queryDocumentList()&#123; return templateDao.findAll(); &#125; /** * 新增文档 */ public TemplateDocument addTemplateDocument(TemplateDocument entity)&#123; return templateDao.insert(entity); &#125; /** * 修改文档 */ public TemplateDocument modifyTemplateDocument(TemplateDocument entity)&#123; TemplateDocument preModifyDocument = templateDao.findById(entity.getId()).get(); preModifyDocument.setName(entity.getName()); return templateDao.save(preModifyDocument); &#125; /** * 删除文档 */ public void deleteDocumentById(String id)&#123; templateDao.deleteById(id); &#125; public Optional&lt;TemplateDocument&gt; getFileById(String id)&#123; return templateDao.findById(id); &#125; public TemplateDocument findOneByName(String fileName)&#123; List&lt;TemplateDocument&gt; result = templateDao.findByName(fileName); if (CollectionUtil.isEmpty(result))&#123; return new TemplateDocument(); &#125; return result.get(0); &#125;&#125; 编写控制层代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051@Api(tags = \"MongoDB 文件管理\")@RestController@RequestMapping(\"/template\")public class TemplateController &#123; @Autowired private TemplateService templateService; @ApiOperation(\"小文件上传接口\") @PostMapping(\"/upload\") public ServerResponse mongoFileUploda(@RequestParam(\"file\") MultipartFile file) throws IOException &#123; TemplateDocument entity = new TemplateDocument(); entity.setId(UUID.fastUUID().toString()); entity.setName(file.getOriginalFilename()); entity.setContent(new Binary(file.getBytes())); return ServerResponse.createBySuccess(templateService.saveFile(entity)); &#125; @ApiOperation(\"小文件下载接口\") @GetMapping(\"/download\") public ResponseEntity&lt;Object&gt; mongoFileDownload(@RequestParam String id) &#123; Optional&lt;TemplateDocument&gt; file = templateService.getFileById(id); if (file.isPresent()) &#123; return ResponseEntity.ok() .header(HttpHeaders.CONTENT_DISPOSITION, \"fileName=\\\"\" + file.get().getName() + \"\\\"\") .header(HttpHeaders.CONTENT_TYPE, \"application/octet-stream\") .body(file.get().getContent().getData()); &#125; else &#123; return ResponseEntity.status(HttpStatus.NOT_FOUND).body(\"File was not fount\"); &#125; &#125; @ApiOperation(\"文档列表查询\") @GetMapping(\"/queryDocumentList\") public ServerResponse queryDocumentList()&#123; return ServerResponse.createBySuccess(templateService.queryDocumentList()); &#125; @ApiOperation(\"文件名搜索\") @GetMapping(\"/searchByFileName\") public ServerResponse searchByFileName(String fileName)&#123; return ServerResponse.createBySuccess(templateService.findOneByName(fileName)); &#125; @ApiOperation(\"根据文件ID读取文件内容并返回\") @GetMapping(\"/getDataByFileId\") public ServerResponse getDataByFileId(@RequestParam String fileId)&#123; return ServerResponse.createBySuccess(templateService.getDataByFileId(fileId)); &#125;&#125; B. 大文件存储 大文件存储，使用有 Spring Data 依赖中提供的 GridFsTemplate，跟 gridFs 进行交互。 配置信息： 设置 MongoDB 文件上传的上限 往 Spring 容器中注入 GridFSBucket， 用于打开下载流 123456# application.ymlspring: servlet: # 设置文件上传上限 multipart: max-file-size: 1024MB max-request-size: 1024MB 12345678910111213141516# MongoConfig.java// MongoDB 配置文件@Configurationpublic class MongoConfig &#123; @Value(\"$&#123;spring.data.mongodb.database&#125;\") private String dbName; /** * 往 Spring 容器中注入 GridFSBucket， 用于打开下载流 */ @Bean public GridFSBucket getGridFsBucket(MongoClient mongoClient) &#123; MongoDatabase mongoDatabase = mongoClient.getDatabase(dbName); return GridFSBuckets.create(mongoDatabase); &#125;&#125; 实体类代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748/** * 大文件存储实体类 */@Data@Documentpublic class HugeFileEntity &#123; /** * 主键ID */ @Id private String id; /** * 创建时间 */ private Date creationDate; /** * 最后修改时间 */ private Date lastUpdateTime; /** * 文件名 */ private String name; /** * 文件大小 */ private Long size; /** * 文件 MD5 加密值 */ private String md5; /** * 文件类型 */ private String contentType; /** * 文件名后缀 */ private String fileType; /** * mongo gridFS 的ID */ private String gridFsId; /** * 文件内容 */ private byte[] content;&#125; Service 层： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100@Servicepublic class HugeFileService &#123; @Autowired private MongoTemplate mongoTemplate; @Autowired private GridFsTemplate gridFsTemplate; @Autowired private GridFSBucket gridFSBucket; /** * 文件新增 */ public HugeFileEntity fileAdd(MultipartFile uploadFile) throws IOException &#123; if (uploadFile == null) &#123; return null; &#125; String fileName = uploadFile.getOriginalFilename(); Builder&lt;HugeFileEntity&gt; entityBuilder = Builder.of(HugeFileEntity::new); entityBuilder .with(HugeFileEntity::setContentType, uploadFile.getContentType()) .with(HugeFileEntity::setFileType, StrUtil.subAfter(fileName, \".\", true)) .with(HugeFileEntity::setCreationDate, new Date()) .with(HugeFileEntity::setName, fileName) .with(HugeFileEntity::setSize, uploadFile.getSize()) .with(HugeFileEntity::setLastUpdateTime, new Date()) .with(HugeFileEntity::setMd5, MD5.create().digestHex(uploadFile.getInputStream())); String gridFsId = this.uploadFile(uploadFile.getInputStream(), uploadFile.getContentType()); entityBuilder.with(HugeFileEntity::setGridFsId, gridFsId); return mongoTemplate.save(entityBuilder.build()); &#125; /** * 上传文件到 gridFS */ public String uploadFile(InputStream inputStream, String contentType) &#123; String fileName = IdUtil.objectId(); return gridFsTemplate.store(inputStream, fileName, contentType).toString(); &#125; /** * 文件删除 */ public void deleteFile(String id) &#123; // 查询待删除文件 HugeFileEntity entity = mongoTemplate.findById(id, HugeFileEntity.class); if (entity != null) &#123; // 删除文件在gridFS中对应的fs.chunk和fs.files记录 Query deleteFileQuery = new Query().addCriteria(Criteria.where(\"_id\").is(entity.getGridFsId())); gridFsTemplate.delete(deleteFileQuery); // 删除存储在collection中的文档记录 Query query = new Query(Criteria.where(\"id\").is(entity.getId())); mongoTemplate.remove(query, HugeFileEntity.class); &#125; &#125; /** * 主键ID查询文件 */ public Optional&lt;HugeFileEntity&gt; findFileById(String id, boolean useContent) throws IOException &#123; HugeFileEntity entity = mongoTemplate.findById(id, HugeFileEntity.class); if (entity == null) &#123; return Optional.empty(); &#125; if (!useContent) &#123; return Optional.of(entity); &#125; Query gridFsQuery = new Query().addCriteria(Criteria.where(\"_id\").is(entity.getGridFsId())); GridFSFile file = gridFsTemplate.findOne(gridFsQuery); // 打开流下载对象 GridFSDownloadStream ins = gridFSBucket.openDownloadStream(file.getObjectId()); if (ins.getGridFSFile().getLength() &lt;= 0) &#123; return Optional.empty(); &#125; // 获取流对象 GridFsResource resource = new GridFsResource(file, ins); // 获取数据 entity.setContent(IoUtil.readBytes(resource.getInputStream())); return Optional.of(entity); &#125; public Optional&lt;HugeFileEntity&gt; findFileById(String id) throws IOException &#123; return this.findFileById(id, false); &#125; /** * 分页查询 */ public List&lt;HugeFileEntity&gt; queryPage(int pageNum, int pageSize) &#123; Query query = new Query().with(Sort.by(Sort.Direction.DESC, \"creationDate\")); long offset = (long) (pageNum - 1) * pageSize; query.skip(offset); query.limit(pageSize); // 排除附件实际内容 Field field = query.fields(); field.exclude(\"content\"); return mongoTemplate.find(query, HugeFileEntity.class); &#125;&#125; Controller 层： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051@Api(tags = \"大文件管理\")@RequestMapping(\"/hugeFile\")@RestControllerpublic class HugeFileController &#123; @Autowired private HugeFileService hugeFileService; /** * 分页查询 */ @ApiOperation(\"分页查询接口\") @GetMapping(\"/queryPage\") public ServerResponse&lt;List&lt;HugeFileEntity&gt;&gt; index(int pageNum, int pageSize) &#123; return ServerResponse.createBySuccess(hugeFileService.queryPage(pageNum, pageSize)); &#125; /** * 文件上传 */ @ApiOperation(\"文件上传接口\") @PostMapping(\"/upload\") public ServerResponse&lt;HugeFileEntity&gt; uploadFile(MultipartFile uploadFile) throws IOException &#123; return ServerResponse.createBySuccess(hugeFileService.fileAdd(uploadFile)); &#125; /** * 文件下载 */ @ApiOperation(\"文件下载接口\") @PostMapping(\"/downloadFile\") public ResponseEntity&lt;Object&gt; downloadFile(String id) throws IOException &#123; // 根据文档主键ID下载文件 Optional&lt;HugeFileEntity&gt; entity = hugeFileService.findFileById(id, true); return entity.&lt;ResponseEntity&lt;Object&gt;&gt;map(hugeFileEntity -&gt; ResponseEntity.ok() .header(HttpHeaders.CONTENT_DISPOSITION, \"fileName=\" + hugeFileEntity.getName()) .header(HttpHeaders.CONTENT_TYPE, hugeFileEntity.getContentType()) .header(HttpHeaders.CONTENT_LENGTH, hugeFileEntity.getSize() + \"\") .header(\"Connection\", \"close\") .body(hugeFileEntity.getContent())).orElseGet(() -&gt; ResponseEntity.status(HttpStatus.NOT_FOUND).body(\"不存在的文件\")); &#125; /** * 文件删除 */ @ApiOperation(\"文件删除接口\") @DeleteMapping(\"/delete\") public ServerResponse&lt;HugeFileEntity&gt; deleteFile(String id) &#123; hugeFileService.deleteFile(id); return ServerResponse.createBySuccessMessage(\"删除成功\"); &#125;&#125; 三、大文件存储关系图 实体类关系图","tags":[{"name":"日积笔记","slug":"日积笔记","permalink":"http://tech.noexception.cn/tags/%E6%97%A5%E7%A7%AF%E7%AC%94%E8%AE%B0/"}]},{"title":"ARTS 打卡——Weekly ③","date":"2021-05-25T03:34:41.000Z","path":"2021/05/25/arts-03/","text":"日拱一卒，功不唐捐。 Algorithm——算法题 字母异位词分组 问题描述 给定一个字符串数组，将字母异位词组合在一起。字母异位词指字母相同，但排列不同的字符串。 解题思路 首先想到的思路就是，模仿 HashMap 的方式，通过实现一个 hash 函数，得到一个单词的哈希值，然后作为这个单词的 key 缓存到一个 Cache 中，如果是字母以为词，放入相同的一个分组中，否则放入另外的分组中。最后，返回分好组的结果即可。（这个 hash 函数的算法可以有很多，我想到的最简单的实现就是，将输入的单词排序，因为字母异位词的特征就是，单词所组成的字母是相同的，但是顺序不同。所以重新排序得到的结果应该就是一致的，满足我们 hash 散列函数的要求。） 第二个思路，也是从网友的帖子中发现的一个比较有意思的算法。即：利用质数代表26个字母，让乘积结果作为hash值 这种算法比我们排序的算法要快上许多。实现简单，思路巧妙。 解答代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667// 解法1：class Solution &#123; private String hashString(String str) &#123; char[] table = str.toCharArray(); for (int i = 0; i &lt; table.length; i++) &#123; for (int j = i; j &lt; table.length; j++) &#123; if (table[i]&gt;table[j])&#123; char temp = table[i]; table[i] = table[j]; table[j] = temp; &#125; &#125; &#125; return String.valueOf(table); &#125; public List&lt;List&lt;String&gt;&gt; groupAnagrams(String[] strs) &#123; List&lt;List&lt;String&gt;&gt; result = new ArrayList&lt;&gt;(); Map&lt;String, List&lt;String&gt;&gt; crucible = new HashMap&lt;&gt;(); for (String param : strs) &#123; String hashValue = hashString(param); if (!crucible.keySet().contains(hashValue))&#123; // 尚未存在 crucible.put(hashValue, new ArrayList&lt;&gt;()); &#125; crucible.get(hashValue).add(param); &#125; for (String key : crucible.keySet()) &#123; result.add(crucible.get(key)); &#125; return result; &#125;&#125;// 解法2：class Solution &#123; private Long hashString(String str) &#123; int[] primeNum = &#123;2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101&#125;; char[] table = str.toCharArray(); Long product = 1L; for (int i = 0; i &lt; table.length; i++) &#123; product *= primeNum[table[i] - 97]; &#125; return product; &#125; public List&lt;List&lt;String&gt;&gt; groupAnagrams(String[] strs) &#123; List&lt;List&lt;String&gt;&gt; result = new ArrayList&lt;&gt;(); Map&lt;Long, List&lt;String&gt;&gt; crucible = new HashMap&lt;&gt;(); for (String param : strs) &#123; Long hashValue = hashString(param); if (!crucible.keySet().contains(hashValue))&#123; // 尚未存在 crucible.put(hashValue, new ArrayList&lt;&gt;()); &#125; crucible.get(hashValue).add(param); &#125; for (Long key : crucible.keySet()) &#123; result.add(crucible.get(key)); &#125; return result; &#125;&#125; Review——阅读一篇英文文章 ## Tip——学习一个技巧 ### 控制反转、依赖反转、依赖注入，这三者有何区别和联系 #### 控制反转（IOC） - 这里的“控制”指的是对程序执行流程的控制，而“反转”指的是在没有使用框架之前，程序员自己控制整个程序的执行。在使用框架之后，整个程序的执行流程可以通过框架来控制。**流程的控制权从程序员“反转”到了框架。** - 控制反转并不是一种具体的实现技巧，而是一个比较笼统的设计思想，一般用来指导框架层面的设计。 #### 依赖注入（DI） - 依赖注入跟控制反转恰恰相反，它是一种具体的编码技巧。 - **解释**：不通过`new()`的方式在类内部创建依赖类对象，而是将依赖的类对象在外部创建好之后，通过构造函数、函数参数等方式传递（或注入）给类使用。 - 例子对比： 123456789101112131415161718192021222324252627282930313233343536373839// 非依赖注入实现方式public class Notification &#123; private MessageSender messageSender; public Notification() &#123; this.messageSender = new MessageSender(); //此处有点像hardcode &#125; public void sendMessage(String cellphone, String message) &#123; //...省略校验逻辑等... this.messageSender.send(cellphone, message); &#125;&#125;public class MessageSender &#123; public void send(String cellphone, String message) &#123; //.... &#125;&#125;// 使用NotificationNotification notification = new Notification();// 依赖注入的实现方式public class Notification &#123; private MessageSender messageSender; // 通过构造函数将messageSender传递进来 public Notification(MessageSender messageSender) &#123; this.messageSender = messageSender; &#125; public void sendMessage(String cellphone, String message) &#123; //...省略校验逻辑等... this.messageSender.send(cellphone, message); &#125;&#125;//使用NotificationMessageSender messageSender = new MessageSender();Notification notification = new Notification(messageSender); - 把 MessageSender 定义成接口，基于接口而非实现编程，继续优化： 1234567891011121314151617181920212223242526272829303132333435public class Notification &#123; private MessageSender messageSender; public Notification(MessageSender messageSender) &#123; this.messageSender = messageSender; &#125; public void sendMessage(String cellphone, String message) &#123; this.messageSender.send(cellphone, message); &#125;&#125;public interface MessageSender &#123; void send(String cellphone, String message);&#125;// 短信发送类public class SmsSender implements MessageSender &#123; @Override public void send(String cellphone, String message) &#123; //.... &#125;&#125;// 站内信发送类public class InboxSender implements MessageSender &#123; @Override public void send(String cellphone, String message) &#123; //.... &#125;&#125;//使用NotificationMessageSender messageSender = new SmsSender();Notification notification = new Notification(messageSender); #### 依赖注入框架（DI Frameword） - 在采用依赖注入实现的 Notification 类中，虽然我们不需要用类似 hard code 的方式，在类内部通过 new 来创建 MessageSender 对象，但是，这个创建对象、组装（或注入）对象的工作紧紧是被移动到了更上层代码而已，还是需要程序员自己来实现。 - 可以通过框架来自动完成，只需要通过依赖注入框架提供的扩展点，简单配置一下所有需要创建的类对象、类与类之间的依赖关系，就可以实现由框架来自动创建对象、管理对象的生命周期、依赖注入等原本需要程序员来做的事情。 - 这类框架有很多： Google Guice、Java Spring、Pico Container、Butterfly Container。 #### 依赖反转原则（DIP） - 原文：High-level modules shouldn't depend on low-level modules. Both modules should depend on abstractions. In addition, abstractions shouldn't depend on details. Details depend on abstractions. - 定义：高层模块不要依赖低层模块。高层模块和低层模块应该通过抽象来互相依赖。除此之外，抽象不要依赖具体实现细节，具体实现细节依赖抽象。 - 这条原则主要是用来指导框架层面的设计，跟前面讲到的控制反转类似。 ##### 用 Tomcat 作为例子： - Tomcat 是运行 Java Web 应用程序的容器，Tomcat 是高层模块，Java Web 是低层模块。两者之间没有直接的依赖关系，两者都依赖同一个“抽象”，就是 Servlet 规范。Servlet 规范不依赖具体的 Tomcat 容器和应用程序的实现细节，而两者都依赖 Servlet 规范。 ## Share——分享一篇有观点的文章 - &lt;a href=&quot;https://coolshell.cn/articles/21113.html&quot; target=&quot;_blank&quot;&gt;[ 百度为什么掉队了 ]&lt;/a&gt;","tags":[{"name":"ARTS","slug":"ARTS","permalink":"http://tech.noexception.cn/tags/ARTS/"},{"name":"打卡","slug":"打卡","permalink":"http://tech.noexception.cn/tags/%E6%89%93%E5%8D%A1/"}]},{"title":"ARTS 打卡——Weekly ②","date":"2021-05-18T03:06:26.000Z","path":"2021/05/18/arts-02/","text":"日拱一卒，功不唐捐。 Algorithm——算法题 循环链表 问题描述： 给定一个链表，判断链表中是否有环。 如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。 为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。注意：pos 不作为参数进行传递，仅仅是为了标识链表的实际情况。 如果链表中存在环，则返回 true 。 否则，返回 false 。 解题思路： 首先第一个想到的思路就是： 创建一个集合，用于存放每一个遍历过的节点； 遍历给定的链表，将每一个元素都放入上一步创建的集合当中； 在遍历的过程中，判断当前节点是否存在于集合当中，如果存在则说明，是循环链表； 其次，遍历到链表末尾的时候，next指向的为 null，则说明不是循环链表； 然后，想到的第二个思路就是： 用两个指针，分别是快慢指针； 快指针步长是慢指针的两倍（三倍也行）; 一直这样遍历下去，如果是循环链表的话，则快慢指针终会相遇； 否则，当快指针的next或者慢指针的next指向null时，则说明不是循环链表 解答代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162// 解法一：/** * Definition for singly-linked list. * class ListNode &#123; * int val; * ListNode next; * ListNode(int x) &#123; * val = x; * next = null; * &#125; * &#125; */public class Solution &#123; public boolean hasCycle(ListNode head) &#123; ListNode current = head; Set&lt;ListNode&gt; listNodePool = new HashSet&lt;&gt;(); while(true)&#123; if (listNodePool.contains(current))&#123; return true; &#125; if (current == null)&#123; return false; &#125; listNodePool.add(current); current = current.next; &#125; &#125;&#125;/** * Definition for singly-linked list. * class ListNode &#123; * int val; * ListNode next; * ListNode(int x) &#123; * val = x; * next = null; * &#125; * &#125; */ // 解法二：public class Solution &#123; public boolean hasCycle(ListNode head) &#123; if (head == null || head.next == null) &#123; return false; &#125; // 使用快慢指针的方法 ListNode fast = head; ListNode slow = head; while (true) &#123; slow = slow.next; fast = fast.next.next; if (fast == null || fast.next == null) &#123; return false; &#125; if (fast == slow || slow == fast.next) &#123; return true; &#125; &#125; &#125;&#125; Review——阅读一篇英文文章 [ The software architect fallacy（软件架构师谬论） ] 看法： 这篇文章用了一个非常生动形象的例子阐述了瀑布型开发模型的弊端，并提出了一下一些思考点： 能够看到产品3-5年后的样子吗？ 在未来还需要投入多少工作量才能让产品上线？ 如果第一个版本能够使产品更稳定地被更高的客户采用，那么团队是否有可能对产品的关键区域进行返工？ 我们有哪些决定会限制或者改变我们产品最终的形态？ 在快速迭代的同时，我们能够保证产品基础功能的稳定运行吗？ 是否存在有可以重构的模块或者部分？ Tip——学习一个技巧 设计原则——贫血模型与充血模型 基于贫血模型的 MVC 三层架构开发模式，是一种面向过程的编程风格，被称为“反模式”。领域驱动设计是基于充血模型的开发模式，越来越被人提倡。 贫血模型： 贫血模型的定义： 在大多数的后端项目中，Entity 和 DAO(Repository) 组成数据访问层，BO 和 Service 组成业务逻辑层，VO 和 Controller 组成接口层。BO 是一个纯粹的数据结构，只包含数据，不包含任何业务逻辑。业务逻辑集中在 Service 中。通过 Service 来操作 BO。Service 层的数据和业务逻辑，被分割为 BO 和 Service 两个类。这种 BO 不包含业务逻辑的类，就叫做 贫血模型。贫血模型将数据与操作分离，破坏了面向对象的封装特性，所以说是一种典型的面向对象的编程风格。 充血模型： 领域驱动设计 DDD, 主要用来指导如何解耦业务系统，划分业务模块，定义业务领域模型及其交互。（2004年提出，但是由于微服务的盛行加速了 DDD 的兴起） 做好 DDD 的关键是：看人对自己所做业务的熟悉程度，而不是对领域驱动设计这个概念本身的掌握程度。 充血模型的定义： 数据和对应的业务逻辑被封装到同一个类中国，因此，充血模型满足面向对象的封装特性，是典型的面向对象编程风格。 基于充血模型的DDD开发模式实现的代码，也是按照 MVC 三层架构分层的。Controller 层负责暴露接口，Repository 层负责数据存取， Service 层负责核心业务逻辑。区别主要在 Service 层。 基于贫血模型的传统的开发模式，重 Service 轻 BO；基于充血模型的 DDD 开发模式，轻 Service 重 Domain. 贫血模型之所以受欢迎的原因： 业务简单，基本就是基于SQL的CRUD操作，无需动脑子精心设计充血模型，贫血模型就足以应付这种简单业务的工作。 充血模型的设计要比贫血模型更加有难度。充血模型是一种面向对象的编程风格，一开始就要设计好针对数据要暴露那些操作，定义哪些业务逻辑。贫血模型只需要定义数据，后续有新的功能开发需求，就在 Service 层定义操作，不需要是事先做太多设计。 思维固化。这种贫血模型已成为 Web 开发中事实上的标准，难以改变。 充血模型的应用场景： 基于贫血模型的传统开发模式，比较适合业务比较简单的系统开发。 基于充血模型的DDD开发模式，更适合业务复杂的系统开发。如： 包含各种利息计算模型； 还款模型等复杂业务的金融系统 一句话概括平时的开发：街道一个后端接口的开发需求的时候，就去看接口需要的数据对应到数据库中国，需要哪张表或者哪几张表，然后思考如何编写SQL语句来获取数据。之后就是定义 Entity、BO、VO，然后模板式地往对应的 Repository、Service、Controller 类中添加代码。 在基于充血模型的 DDD 的开发模式下，我们需要事先理清楚所有的业务，定义领域模型所包含的属性和方法。领域模型相当于可复用的业务中间层。新功能需求的开发，都基于之前定义好的这些领域模型来完成。 越复杂的系统，对代码的复用性、易维护性要求就越高，我们就越应该花更多的时间和精力在前期设计上。 而基于充血模型的 DDD 开发模式，正好需要我们前期做大量的业务调研、领域模型设计，所以它更加适合这种复杂系统的开发。 Share——分享一篇有观点的文章 [ 使用简单的逻辑方法进行独立思考 ] 笔记： 五步思考： 信息数据可考证； 处理集合和其包含关系； 在数学的逻辑包含中，超集的定义可以适用于子集，通过子集的特征可以对超集进行探索，但是没法定义超集。 集合的大小也是一个很重要的事，幸存者偏差会是一个很容易让人掉下去的陷阱，因为可能会有很大的样本集可能在你的视线盲区。 处理逻辑因果关系； 因果关系出问题的文章读多了是对大脑有损伤的，要尽量远离。 找到靠谱的基准线； 智者建桥，愚者建墙 更加深入和高维思考；","tags":[{"name":"ARTS","slug":"ARTS","permalink":"http://tech.noexception.cn/tags/ARTS/"},{"name":"打卡","slug":"打卡","permalink":"http://tech.noexception.cn/tags/%E6%89%93%E5%8D%A1/"}]},{"title":"ARTS 打卡——Weekly ①","date":"2021-05-11T10:54:23.000Z","path":"2021/05/11/arts-01/","text":"日拱一卒，功不唐捐。 Algorithm——算法题 杨辉三角 问题描述： 给定一个非负整数 numRows，生成杨辉三角的前 numRows 行。 在杨辉三角中，每个数是它左上方和右上方的数的和。 解题思路： 首先看杨辉三角的规律： 行数跟个数相等 每一行的总和等于2的n-1次方，n为当前行数 每行都是回文 每行第二个数（如果有的话），都是n-1，且n为当前行数 从第一行开始生成的话，奇数行中间那个数，就正好等于上一行中间两个数之和 首先生成当前航的前一半的数字，剩下的根据先前生成的倒序插入即可 处理流程大致上就分为： 计算并标记当前生成行的中位坐标，并标记当前行是否是奇数行（奇数行需要生成回文数列中的最大值） 计算并生成当前行前半部分数据 计算奇数行回文中间数值 将前半部分数值倒序插入当前行中，不全数据 解答代码： 123456789101112131415161718192021222324252627282930313233class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; generate(int numRows) &#123; List&lt;List&lt;Integer&gt;&gt; resultArray = new ArrayList&lt;&gt;(); List&lt;Integer&gt; subArray = null; for (int i = 0; i &lt; numRows; i++) &#123; subArray = new ArrayList&lt;&gt;(); int mid = (i + 1) / 2; int mod = (i + 1) % 2; if (mid &lt; 1) &#123; subArray.add(1); &#125; for (int j = 0; j &lt; mid; j++) &#123; if (j == 0) &#123; subArray.add(1); continue; &#125; if (j == 1) &#123; subArray.add(i); continue; &#125; subArray.add(resultArray.get(i - 1).get(j) + resultArray.get(i - 1).get(j - 1)); &#125; if (mod == 1 &amp;&amp; mid &gt;= 1) &#123; subArray.add(resultArray.get(i - 1).get(mid) + resultArray.get(i - 1).get(mid - 1)); &#125; for (int k = mid; k &gt; 0; k--) &#123; subArray.add(subArray.get(k - 1)); &#125; resultArray.add(subArray); &#125; return resultArray; &#125;&#125; Review——阅读一篇英文文章 [ What is HTTP/3, and Why Does it Matter? ] 看法： HTTP/3 基于 Google 在2012年发布的 QUIC 协议，添加了多项功能，比原来基于TCP/IP协议的HTTP要快非常非常多，QUIC 协议基于 UDP 实现，无需3次握手，具有快速安全的特点 支持情况： Chrome: 87+ Edge: 87+ Firefox: 88+ Safari: 14+（需要在开启试验功能才能支持） Tip——学习一个技巧 简单工厂（工厂方法的一种特例） 先来看一段未使用工厂模式的代码 12345678910111213141516171819202122232425262728public class RuleConfigSource &#123; public RuleConfig load(String ruleConfigFilePath) &#123; String ruleConfigFileExtension = getFileExtension(ruleConfigFilePath); IRuleConfigParser parser = null; if (\"json\".equalsIgnoreCase(ruleConfigFileExtension)) &#123; parser = new JsonRuleConfigParser(); &#125; else if (\"xml\".equalsIgnoreCase(ruleConfigFileExtension)) &#123; parser = new XmlRuleConfigParser(); &#125; else if (\"yaml\".equalsIgnoreCase(ruleConfigFileExtension)) &#123; parser = new YamlRuleConfigParser(); &#125; else if (\"properties\".equalsIgnoreCase(ruleConfigFileExtension)) &#123; parser = new PropertiesRuleConfigParser(); &#125; else &#123; throw new InvalidRuleConfigException( \"Rule config file format is not supported: \" + ruleConfigFilePath); &#125; String configText = \"\"; //从ruleConfigFilePath文件中读取配置文本到configText中 RuleConfig ruleConfig = parser.parse(configText); return ruleConfig; &#125; private String getFileExtension(String filePath) &#123; //...解析文件名获取扩展名，比如rule.json，返回json return \"json\"; &#125;&#125; 为了让代码逻辑更加清晰，可读性更好，我们要善于将功能独立的代码封装成函数。 我们可以将代码中设计 parser 创建的部分逻辑剥离出来，抽象成 createParser() 函数。 12345678910111213141516171819202122232425262728293031323334public class RuleConfigSource &#123; public RuleConfig load(String ruleConfigFilePath) &#123; String ruleConfigFileExtension = getFileExtension(ruleConfigFilePath); IRuleConfigParser parser = createParser(ruleConfigFileExtension); if (parser == null) &#123; throw new InvalidRuleConfigException( \"Rule config file format is not supported: \" + ruleConfigFilePath); &#125; String configText = \"\"; //从ruleConfigFilePath文件中读取配置文本到configText中 RuleConfig ruleConfig = parser.parse(configText); return ruleConfig; &#125; private String getFileExtension(String filePath) &#123; //...解析文件名获取扩展名，比如rule.json，返回json return \"json\"; &#125; private IRuleConfigParser createParser(String configFormat) &#123; IRuleConfigParser parser = null; if (\"json\".equalsIgnoreCase(configFormat)) &#123; parser = new JsonRuleConfigParser(); &#125; else if (\"xml\".equalsIgnoreCase(configFormat)) &#123; parser = new XmlRuleConfigParser(); &#125; else if (\"yaml\".equalsIgnoreCase(configFormat)) &#123; parser = new YamlRuleConfigParser(); &#125; else if (\"properties\".equalsIgnoreCase(configFormat)) &#123; parser = new PropertiesRuleConfigParser(); &#125; return parser; &#125;&#125; 为了让类的职责更加单一、代码更加清晰，我们还可以进一步将 createParser() 函数剥离到一个独立的类中，让这个类只负责对象的创建。 而这个类就是我们所说的 简单工厂模式类 。 1234567891011121314151617181920212223242526272829303132333435363738public class RuleConfigSource &#123; public RuleConfig load(String ruleConfigFilePath) &#123; String ruleConfigFileExtension = getFileExtension(ruleConfigFilePath); IRuleConfigParser parser = RuleConfigParserFactory.createParser(ruleConfigFileExtension); if (parser == null) &#123; throw new InvalidRuleConfigException( \"Rule config file format is not supported: \" + ruleConfigFilePath); &#125; String configText = \"\"; //从ruleConfigFilePath文件中读取配置文本到configText中 RuleConfig ruleConfig = parser.parse(configText); return ruleConfig; &#125; private String getFileExtension(String filePath) &#123; //...解析文件名获取扩展名，比如rule.json，返回json return \"json\"; &#125;&#125;// 简单工厂模式类↓↓↓public class RuleConfigParserFactory &#123; public static IRuleConfigParser createParser(String configFormat) &#123; IRuleConfigParser parser = null; if (\"json\".equalsIgnoreCase(configFormat)) &#123; parser = new JsonRuleConfigParser(); &#125; else if (\"xml\".equalsIgnoreCase(configFormat)) &#123; parser = new XmlRuleConfigParser(); &#125; else if (\"yaml\".equalsIgnoreCase(configFormat)) &#123; parser = new YamlRuleConfigParser(); &#125; else if (\"properties\".equalsIgnoreCase(configFormat)) &#123; parser = new PropertiesRuleConfigParser(); &#125; return parser; &#125;&#125; 在上面的代码实现中，我们每次调用 RuleConfigParserFactory 的 createParser() 的时候，都要创建一个新的 parser。 实际上，如果 parser 可以服用，为了节省内存和对象创建的时间，我们可以将 parser 事先创建好缓存起来。 当调用 createParser() 函数的时候，我们从缓存中取出 parser 对象直接使用。 有点类似于，单利模式 和 简单工厂模式 的结合。作为简单工厂模式的第二种实现方式。 123456789101112131415161718public class RuleConfigParserFactory &#123; private static final Map&lt;String, RuleConfigParser&gt; cachedParsers = new HashMap&lt;&gt;(); static &#123; cachedParsers.put(\"json\", new JsonRuleConfigParser()); cachedParsers.put(\"xml\", new XmlRuleConfigParser()); cachedParsers.put(\"yaml\", new YamlRuleConfigParser()); cachedParsers.put(\"properties\", new PropertiesRuleConfigParser()); &#125; public static IRuleConfigParser createParser(String configFormat) &#123; if (configFormat == null || configFormat.isEmpty()) &#123; return null;//返回null还是IllegalArgumentException全凭你自己说了算 &#125; IRuleConfigParser parser = cachedParsers.get(configFormat.toLowerCase()); return parser; &#125;&#125; 在简单工厂模式的代码实现中，有多处 if 分支判断逻辑，违背开闭原则，但权衡扩展性和可读性，这样的代码实现在大多数情况下是没有问题的。 应用多态或设计模式来替代 if 分支判断逻辑，它虽然提高了代码的扩展性，更加符合开闭原则，但也增加了类的个数，牺牲了代码的可读性。 工厂方法 如果非要去除掉代码中的 if 分支逻辑，比较经典的方式就是利用多态。 12345678910111213141516171819202122232425262728293031public interface IRuleConfigParserFactory &#123; IRuleConfigParser createParser();&#125;public class JsonRuleConfigParserFactory implements IRuleConfigParserFactory &#123; @Override public IRuleConfigParser createParser() &#123; return new JsonRuleConfigParser(); &#125;&#125;public class XmlRuleConfigParserFactory implements IRuleConfigParserFactory &#123; @Override public IRuleConfigParser createParser() &#123; return new XmlRuleConfigParser(); &#125;&#125;public class YamlRuleConfigParserFactory implements IRuleConfigParserFactory &#123; @Override public IRuleConfigParser createParser() &#123; return new YamlRuleConfigParser(); &#125;&#125;public class PropertiesRuleConfigParserFactory implements IRuleConfigParserFactory &#123; @Override public IRuleConfigParser createParser() &#123; return new PropertiesRuleConfigParser(); &#125;&#125; 以上，就是工厂方法模式的典型代码实现方式。这样当我们新增一种 parser 的时候，只需要新增一个实现了 IRuleConfigPArserFactory 接口的 Factory 类即可。。 所以，工厂方法比起简单工厂模式更加符合开闭原则。 但是这里面存在一个问题，就是上层使用类，又会变为初版那样工厂对象的创建逻辑耦合进了 load() 函数 1234567891011121314151617181920212223242526272829public class RuleConfigSource &#123; public RuleConfig load(String ruleConfigFilePath) &#123; String ruleConfigFileExtension = getFileExtension(ruleConfigFilePath); IRuleConfigParserFactory parserFactory = null; if (\"json\".equalsIgnoreCase(ruleConfigFileExtension)) &#123; parserFactory = new JsonRuleConfigParserFactory(); &#125; else if (\"xml\".equalsIgnoreCase(ruleConfigFileExtension)) &#123; parserFactory = new XmlRuleConfigParserFactory(); &#125; else if (\"yaml\".equalsIgnoreCase(ruleConfigFileExtension)) &#123; parserFactory = new YamlRuleConfigParserFactory(); &#125; else if (\"properties\".equalsIgnoreCase(ruleConfigFileExtension)) &#123; parserFactory = new PropertiesRuleConfigParserFactory(); &#125; else &#123; throw new InvalidRuleConfigException(\"Rule config file format is not supported: \" + ruleConfigFilePath); &#125; IRuleConfigParser parser = parserFactory.createParser(); String configText = \"\"; //从ruleConfigFilePath文件中读取配置文本到configText中 RuleConfig ruleConfig = parser.parse(configText); return ruleConfig; &#125; private String getFileExtension(String filePath) &#123; //...解析文件名获取扩展名，比如rule.json，返回json return \"json\"; &#125;&#125; 解决方法：我们可以为工厂类再创建一个简单工厂，也就是工厂的工厂，用来创建工厂类对象。 12345678910111213141516171819202122232425262728293031323334353637383940414243// RuleConfigParserFactoryMap 类是创建工厂对象的工厂类，getParserFactory() 返回的是缓存好的单例工厂对象。public class RuleConfigSource &#123; public RuleConfig load(String ruleConfigFilePath) &#123; String ruleConfigFileExtension = getFileExtension(ruleConfigFilePath); IRuleConfigParserFactory parserFactory = RuleConfigParserFactoryMap.getParserFactory(ruleConfigFileExtension); if (parserFactory == null) &#123; throw new InvalidRuleConfigException(\"Rule config file format is not supported: \" + ruleConfigFilePath); &#125; IRuleConfigParser parser = parserFactory.createParser(); String configText = \"\"; //从ruleConfigFilePath文件中读取配置文本到configText中 RuleConfig ruleConfig = parser.parse(configText); return ruleConfig; &#125; private String getFileExtension(String filePath) &#123; //...解析文件名获取扩展名，比如rule.json，返回json return \"json\"; &#125;&#125;//因为工厂类只包含方法，不包含成员变量，完全可以复用，//不需要每次都创建新的工厂类对象，所以，简单工厂模式的第二种实现思路更加合适。public class RuleConfigParserFactoryMap &#123; //工厂的工厂 private static final Map&lt;String, IRuleConfigParserFactory&gt; cachedFactories = new HashMap&lt;&gt;(); static &#123; cachedFactories.put(\"json\", new JsonRuleConfigParserFactory()); cachedFactories.put(\"xml\", new XmlRuleConfigParserFactory()); cachedFactories.put(\"yaml\", new YamlRuleConfigParserFactory()); cachedFactories.put(\"properties\", new PropertiesRuleConfigParserFactory()); &#125; public static IRuleConfigParserFactory getParserFactory(String type) &#123; if (type == null || type.isEmpty()) &#123; return null; &#125; IRuleConfigParserFactory parserFactory = cachedFactories.get(type.toLowerCase()); return parserFactory; &#125;&#125; 问题：什么时候该用工厂方法模式，而非简单工厂模式？ 基于单一职责的设计思想，当创建对象逻辑比较复杂，不只是简单的 new 一下就可以，而是要组合其他类对象，做各种初始化操作的时候，我们推荐使用工厂方法模式，将复杂的创建逻辑拆分到多个工厂类中，让每个工厂类都不至于过于复杂。 而使用简单工厂模式，将所有的创建逻辑都放到一个工厂类中，会导致这个工厂类变得很复杂。 如果对象不可复用，那工厂每次都要返回不同的对象： 使用简单工厂模式实现，包含 if 分支逻辑的实现方式。 避免 if-else 分支逻辑，就推荐使用工厂方法模式。 抽象工厂 场景： 在简单工厂和工厂方法模式中，解析器只根据配置文件格式来分类，但是，如果类有两种分类方式，比如，我们既可以按照配置文件格式来分类，也可以按照解析的对象来分类。 针对这种特殊的场景，如果还是继续用工厂方法来实现的话，我们需要针对每个 parser 都编写一个工厂类。如果未来还需要增加针对业务配置的解析器，那就要再对应地增加工厂类。 过多的类会让系统难维护。 解决方式： 抽象工厂针对这种特殊的场景诞生。我们可以让一个工厂负责创建过个不同类型的对象，而不是只创建一种 parser 对象。 这样可以有效地减少工厂类的个数。 12345678910111213141516171819202122232425262728293031public interface IConfigParserFactory &#123; IRuleConfigParser createRuleParser(); ISystemConfigParser createSystemParser(); //此处可以扩展新的parser类型，比如IBizConfigParser&#125;public class JsonConfigParserFactory implements IConfigParserFactory &#123; @Override public IRuleConfigParser createRuleParser() &#123; return new JsonRuleConfigParser(); &#125; @Override public ISystemConfigParser createSystemParser() &#123; return new JsonSystemConfigParser(); &#125;&#125;public class XmlConfigParserFactory implements IConfigParserFactory &#123; @Override public IRuleConfigParser createRuleParser() &#123; return new XmlRuleConfigParser(); &#125; @Override public ISystemConfigParser createSystemParser() &#123; return new XmlSystemConfigParser(); &#125;&#125;// 省略YamlConfigParserFactory和PropertiesConfigParserFactory代码 应用工厂模式最本质的参考标准： 封装变化：创建逻辑有可能变化，封装成工厂类之后，创建逻辑的变更对调用者透明； 代码复用：创建代码抽离到独立的工厂类之后可以复用； 隔离复杂性：封装复杂的创建逻辑，调用者无需了解如何创建对象； 控制复杂度：将创建代码抽离出来，让原本的函数或类职责更单一，代码更简洁； 为什么没事不要随便用工厂模式创建对象 工厂模式和依赖注入容器 区别 工厂模式中，一个工厂类只负责某个类对象或者某一组相关类对象（继承自同一抽象类或者接口的子类）的创建； DI 容器负责的是整个应用中所有类对象的创建； DI 容器还需要负责配置类的解析、对象声明周期的管理； DI 容器的核心功能 1. 配置解析 背景： 在工厂模式中，工厂类要创建哪个类对象是事先确定好的，并且是写死在工厂类代码中的。作为一个通用的框架来说， 框架代码跟应用代码应该是高度解耦的，DI 容器事先并不知道应用会创建哪些对象 ，不可能把某个应用要创建的对象写死在框架代码中。 所以，我们需要通过一种形式，让应用告知 DI 容器要创建哪些对象。 做法： 将需要由 DI 容器来创建的类对象和创建类对象的必要信息，放到配置文件中。 容器读取配置文件，根据配置文件提供的信息来创建对象。 举例： Spring 容器的配置文件，定义 beans 的依赖关系以及位置 2. 对象创建 背景： 在 DI 容器中国，如果我们给每个类都创建一个工厂列，那项目中类的个数会成倍增加，这回增加代码的维护成本； 做法： 将所有类对象的创建放到一个工厂类中完成。 举例： Spring 容器中的 BeansFactory。 3. 对象声明周期管理 背景： 简单工厂模式有两种实现方式：一种是每次都返回新创建的对象，另一种是每次都返回同一个事先创建好的对象，也就是所谓的单例对象。 做法： 在 Spring 框架中，我们可以通过配置 scope 属性，来区分这两种不同类型的对象。scope=prototype 表示返回新创建的对象，scope=singleton 表示返回单例对象，默认返回单例； Spring 框架中，可以配置对象是否支持懒加载。如果 lazy-init=true，对象在真正被使用到的时候才被创建；如果 lazy-init=false，对象在应用启动的时候就事先创建好。 配置对象的 init-method 和 destroy-method 方法，如： init-method=loadProperties()，destroy-method=updateConfigFile()。 在 DI 容器在创建好对象之后，会主动调用 init-method 属性指定的方法来初始化对象。 在对象被最终销毁之前，DI 容器会主动调用 destroy-method 属性指定的方法来做一些清理工作，比如释放数据库连接池、关闭文件。 实现一个简单的 DI 容器 核心逻辑： 配置文件解析 根据配置文件通过 反射 语法来创建对象 1. 最小原型设计 在最小原型设置中，配置文件中支持的配置语法仅限配置 beans&gt;bean.id.class.scope.lazy-init&gt;constructor-arg.type.value.ref 使用示例： 123456789public class Demo &#123; public static void main(String[] args) &#123; ApplicationContext applicationContext = new ClassPathXmlApplicationContext( \"beans.xml\"); RateLimiter rateLimiter = (RateLimiter) applicationContext.getBean(\"rateLimiter\"); rateLimiter.test(); //... &#125;&#125; 2. 提供执行入口 123456789101112131415161718192021222324252627282930313233343536373839public interface ApplicationContext &#123; Object getBean(String beanId);&#125;public class ClassPathXmlApplicationContext implements ApplicationContext &#123; private BeansFactory beansFactory; private BeanConfigParser beanConfigParser; public ClassPathXmlApplicationContext(String configLocation) &#123; this.beansFactory = new BeansFactory(); this.beanConfigParser = new XmlBeanConfigParser(); loadBeanDefinitions(configLocation); &#125; private void loadBeanDefinitions(String configLocation) &#123; InputStream in = null; try &#123; in = this.getClass().getResourceAsStream(\"/\" + configLocation); if (in == null) &#123; throw new RuntimeException(\"Can not find config file: \" + configLocation); &#125; List&lt;BeanDefinition&gt; beanDefinitions = beanConfigParser.parse(in); beansFactory.addBeanDefinitions(beanDefinitions); &#125; finally &#123; if (in != null) &#123; try &#123; in.close(); &#125; catch (IOException e) &#123; // TODO: log error &#125; &#125; &#125; &#125; @Override public Object getBean(String beanId) &#123; return beansFactory.getBean(beanId); &#125;&#125; ClassPathXmlApplicationContext 负责组装 BeansFactory 和 BeanConfigParser 两个类； 执行流程： 从 classpath 中加载 XML 格式的配置文件，通过 BeanCofigParser 解析为统一的 BeanDefinition 格式； 然后，BeansFactory 根据 BeanDefinition 来创建对象； 3. 配置文件解析 配置文件解析主要包含 BeanConfigParser 接口和 XmlBeanConfigParser 实现类，负责将配置文件解析为 BeanDefinition 结构，以便 BeansFactory 根据这个结构来创建对象。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748public interface BeanConfigParser &#123; List&lt;BeanDefinition&gt; parse(InputStream inputStream); List&lt;BeanDefinition&gt; parse(String configContent);&#125;public class XmlBeanConfigParser implements BeanConfigParser &#123; @Override public List&lt;BeanDefinition&gt; parse(InputStream inputStream) &#123; String content = null; // TODO:... return parse(content); &#125; @Override public List&lt;BeanDefinition&gt; parse(String configContent) &#123; List&lt;BeanDefinition&gt; beanDefinitions = new ArrayList&lt;&gt;(); // TODO:... return beanDefinitions; &#125;&#125;public class BeanDefinition &#123; private String id; private String className; private List&lt;ConstructorArg&gt; constructorArgs = new ArrayList&lt;&gt;(); private Scope scope = Scope.SINGLETON; private boolean lazyInit = false; // 省略必要的getter/setter/constructors public boolean isSingleton() &#123; return scope.equals(Scope.SINGLETON); &#125; public static enum Scope &#123; SINGLETON, PROTOTYPE &#125; public static class ConstructorArg &#123; private boolean isRef; private Class type; private Object arg; // 省略必要的getter/setter/constructors &#125;&#125; 4. 核心工厂类设计 BeansFactory 根据从配置文件解析得到的 BeanDefinition 来创建对象。 如果对象的 scope 属性是 singleton，那对象创建之后会缓存在 singletonObjects 这样一个 map 中，下次再请求此对象的时候，直接从 map 中取出返回，不需要重新创建。 如果对象的 scope 属性是 prototype，那每次请求对象，BeansFactory 都会创建一个新的对象返回。 BeansFactory 创建对象用到的主要技术点是 Java 中的反射语法。 代码示例： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667public class BeansFactory &#123; private ConcurrentHashMap&lt;String, Object&gt; singletonObjects = new ConcurrentHashMap&lt;&gt;(); private ConcurrentHashMap&lt;String, BeanDefinition&gt; beanDefinitions = new ConcurrentHashMap&lt;&gt;(); public void addBeanDefinitions(List&lt;BeanDefinition&gt; beanDefinitionList) &#123; for (BeanDefinition beanDefinition : beanDefinitionList) &#123; this.beanDefinitions.putIfAbsent(beanDefinition.getId(), beanDefinition); &#125; for (BeanDefinition beanDefinition : beanDefinitionList) &#123; if (beanDefinition.isLazyInit() == false &amp;&amp; beanDefinition.isSingleton()) &#123; createBean(beanDefinition); &#125; &#125; &#125; public Object getBean(String beanId) &#123; BeanDefinition beanDefinition = beanDefinitions.get(beanId); if (beanDefinition == null) &#123; throw new NoSuchBeanDefinitionException(\"Bean is not defined: \" + beanId); &#125; return createBean(beanDefinition); &#125; @VisibleForTesting protected Object createBean(BeanDefinition beanDefinition) &#123; if (beanDefinition.isSingleton() &amp;&amp; singletonObjects.contains(beanDefinition.getId())) &#123; return singletonObjects.get(beanDefinition.getId()); &#125; Object bean = null; try &#123; Class beanClass = Class.forName(beanDefinition.getClassName()); List&lt;BeanDefinition.ConstructorArg&gt; args = beanDefinition.getConstructorArgs(); if (args.isEmpty()) &#123; bean = beanClass.newInstance(); &#125; else &#123; Class[] argClasses = new Class[args.size()]; Object[] argObjects = new Object[args.size()]; for (int i = 0; i &lt; args.size(); ++i) &#123; BeanDefinition.ConstructorArg arg = args.get(i); if (!arg.getIsRef()) &#123; argClasses[i] = arg.getType(); argObjects[i] = arg.getArg(); &#125; else &#123; BeanDefinition refBeanDefinition = beanDefinitions.get(arg.getArg()); if (refBeanDefinition == null) &#123; throw new NoSuchBeanDefinitionException(\"Bean is not defined: \" + arg.getArg()); &#125; argClasses[i] = Class.forName(refBeanDefinition.getClassName()); argObjects[i] = createBean(refBeanDefinition); &#125; &#125; bean = beanClass.getConstructor(argClasses).newInstance(argObjects); &#125; &#125; catch (ClassNotFoundException | IllegalAccessException | InstantiationException | NoSuchMethodException | InvocationTargetException e) &#123; throw new BeanCreationFailureException(\"\", e); &#125; if (bean != null &amp;&amp; beanDefinition.isSingleton()) &#123; singletonObjects.putIfAbsent(beanDefinition.getId(), bean); return singletonObjects.get(beanDefinition.getId()); &#125; return bean; &#125;&#125; 思考题 BeansFactory 类中的 createBean() 函数是一个递归函数。当构造函数的参数是 ref 类型时，会递归地创建 ref 属性指向的对象。如果我们在配置文件中错误地配置了对象之间的依赖关系，导致存在循环依赖，那 BeansFactory 的 createBean() 函数是否会出现堆栈溢出？又该如何解决这个问题呢？ demo 位于当前目录下的 dependencycircle 目录下 Share——分享一篇有观点的文章 [ 程序员如何把控自己的职业 ]","tags":[{"name":"ARTS","slug":"ARTS","permalink":"http://tech.noexception.cn/tags/ARTS/"},{"name":"打卡","slug":"打卡","permalink":"http://tech.noexception.cn/tags/%E6%89%93%E5%8D%A1/"}]},{"title":"2021年度计划及目标","date":"2021-01-25T05:51:08.000Z","path":"2021/01/25/2021-purpose/","text":"勤劳温柔，还善良 Incorrect Password! No content to display! U2FsdGVkX1+qbDDps4FT3E1kp9MBMNR+veqQeAtU+NwwRwsDI5Olr4xIC4AQXaeySo8tHe6KxU+znM2j7Xq5hlj7TXCAiB9jBmS176fUi1sN0N+KXILRsxyQ0qwepUurH+HEpS83gn0it0cZlt0XYcWKdOVydFKEdNrHcG6KNEvqdcpq6a6WjrFgyRYfmj//WQ+/vrQ3OEJ15fX2sKuUrGwIOZjwVJJccuyLGHWXiETvt357ouwKj2YcJNGHXUCHcK7migizyhnrDw8FrRvrAzQICEF1XfvQL0Dek/OP5fVPNyeI7mBaxXJPYAn266uIFELAafkYiEHSZ31gyprUNTqeEGINlZoI4XJQ156qaxCSTSH3BGP6xJHneNkmLHgLGF7WSh8uDRrzx7rDrv+ZHVtcHOrZviH0a3wY29jyJ2fI6bKhyCBs38MfkTaW+QQakMolxYM+sO/YdmpKfJ1nkqXH45WCXE9/vTwPjGkdfCjaBhBST71HSfLyakbmip6hrHKMUNpA4ZPbYwYJ3xKUIFH4N0MxCVoGA/7IJAk/H5K+EPmlbu5ynF5jlnVQ9UJygeVia+b9xNDVy0fMVeOICalFlfV9VjblT8oAycNSBqV4NzCig/x+h0YFdTbNe+/+","tags":[{"name":"规划","slug":"规划","permalink":"http://tech.noexception.cn/tags/%E8%A7%84%E5%88%92/"},{"name":"目标","slug":"目标","permalink":"http://tech.noexception.cn/tags/%E7%9B%AE%E6%A0%87/"}]},{"title":"先定一个小目标","date":"2020-07-07T13:23:53.000Z","path":"2020/07/07/one-purpose/","text":"勤劳温柔，还善良 Incorrect Password! No content to display! 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","tags":[{"name":"小目标","slug":"小目标","permalink":"http://tech.noexception.cn/tags/%E5%B0%8F%E7%9B%AE%E6%A0%87/"}]},{"title":"2019年度总结——暨2020年度计划","date":"2020-01-21T06:02:36.000Z","path":"2020/01/21/2020summary/","text":"勤劳温柔，还善良 Incorrect Password! No content to display! U2FsdGVkX1+qLmrJb/hJ8BWD06cV6E3iGvEU4qKuNEtqxRVup5MOu+VsNWexUZ0yg800H9GA+XKNpaW7A8M0DSMnmJ8CerttJD9oapaWwhpJ7Knjc+34i0s+AktVU/j4halQhT3KDN8tcXgQynQjf3RShf6bssGS0YZGyU2AwPBCfc8tKV3zz1VXw7VmyFHywW4CbFozaXZHvJMtRJBv7Wx9MHBvbguNWtSoe+zQQU4TBYIPTg+eyAxEDpUgQSrP7RqAqa8V+mcPwzD2CtjTSB/zr1rdQKuOXGZhD9zizBZNQmg87w3maug8swMXEVCEdVehqV98UzHjV+gyPq6osFrIPpn/T3Px1P1ygpGzh2ytl41C6OG23Y+h91f2WKlsBabsMHQ7qvS6CbIDm8RbHCkwGX3XxdUGtOKqJXGC5gBPFjCppTDZ3E9dI/vHbmDetkgxHHo1TISD5rQb1q2vc2pY6eIYd8gBuUzy0DTQA1RQssL43sc8wXmCL7V4iYSd5Ju1wyossEIgXb1nBQdlvMsFJTdmgnKlAkO+h4EzEUoPK2X5DeqAEcHoCwN8eOcJZsPUsECPWuYNIaHAdQQtRFwrml5dfJVy/Rd/mMdJWAobrmuUgBTddFyxspO0/kafWINNgPekrQ+gH1Lyba1LqlUbYjJBa4jKOMHBLosN+nKZDMiWmXj2U4xVaTwESGab3qJF/1hMZqtPdhgOLqG17rHcH7BK7d7xk99GodmCqMaTMsLKuKAjoClEAxqPlAgpaJ0CYP1r0uWKFP2BEtQQoB27SBpv3Hq0u2web/pRrXiPG/2xCJwdQ1sX+eWFmbLoLG9grZLD9W0BP0XIZ2qcp2oX5sbPWl0l/VR1g2c8DRK8sjt4JCgZ9DkoF/c7GtQrq1/6pvAIuJ1UMFd8c7J7IEToAdm9QflSbgeYjDuMui1sKPbU5Oy4OSzdb56+NmsMg4MPIX4V/dbJWY5JyfpEt/S3Vso4nko8NO+e8lZcjlysAPWPx9zAb9J0XwIkrq3EjFyFxqGiKdwpYJ3B0yTi2CM9V9nj6OiFJAAVMx6hF2+7ajRVexqh0N2RxMp33KDWNBMSPowGkEjC9wEGy1P3jAyCXd4FiZ6Ab1tvgIxih5fQCiQAmN094+AMFSCDdRnn9r56CYHrEum8EmKjjRems7NyMojxOTG2FMItwmVI3iY3XzjZI71r1AsnViYhvf6j9xJx2WzVgrDVOUyLpFu6/YVsZQ1x5ikHHThjXG6LVB61PPvEjFKJEEQPfxgtiSFpEdXuL0HiDBpMHYM5QTT6sKMQLacgLsSA4lbFtBS6Qi8mHD+rox/bwe9SBiCCZKhY8u7+g+/1RBYowxiNjq//KjSUBYKsonb3RluEys2CMTPNT3UOqtYubpSxoAirNhe4sSBh65uURe54bXCHmYIiXyr50Dz5anAqXhkbFbjo4PHuYv5OTh64nSM37hxV7A1rLoGB6TdWJmKhMzLeEi2u2sHLTNyXa7wBPSYCxRPlQ8pJj6CtkcJk7qnU795eZK/xNrH9H+y9+ybCFo7X7rZDJoH9xxQ9LPALl1d+S7EluH2nT8GEk8HVey9+kFOAe1FyLpPNw2OZFqxepxZPgR8tD1OC2bkQ71fBYwIr12+LfOp/PtpyTsp7R56GEf/C0Ak21ovdxP1TJDAe3t7wKrHwZlpzuI1HTPES56kINSVWkn+W7I4+/p1tpZslFC6pkqXLDk9lMKgUiAWxYkTI1dgz2KH6U1D6i5dD/nElpMhwobSHfhzU4A7j6zkriv4ZwtQPz1blWnswfnZKtl+Cn5pU87JM/bF685eAeQydBym+bvvdSLIqG/3e2OkkEnWpeZWV+Zepqi7NLcGSHg1267IlUnIa8TqNW78VDsNSoO+lnYIL1uu7TnJawZUi4A54E9DhaQ/CFiTFOPvbac9HDt5YW2H38u3gVCV+Xbj/aS0vgEFhS72GEW5dQfsxRiq9NvLVlulYOjlFGETt76J9/lDdONlt3fmt+6ljpj1QMctNid42oNns89Vdwtkp3QGAVhfr90I99UDOX9jA0RMvvQQPpxHl5iyoVfse7jxisIWySFkJQDqRUE/6J9ZwauVgRsB3ds3dCewFlUjxmVej7vgYUi7pCFZbl+E5WuxtYHPI6zHCI/gxH3FP/V+yvSHaArciR0OoVIwzsL44hDEpIaAOZf/mzuWL6NrMLp0yQHxhbxfLsRx4HmM55wauej1x6hNM7/6tU5OqQGMjmaaX8krDda6EfZmzEW+zyImKUhfsecqt6JngMshc03VIBb7RcGtkwH8l42YT+aMyNcef9cr5iS9wcPF6txZ593ervU+7kzR+41KhbleBSoyxsUoIGtHAj66OcSFdmtNB0q329FxwKouc6tOwKYHIslb/m8mb1RO08QQ5W7npjgtlFvN9Ensfavo+ltTPvpIrdkQOS4nkHHZOA6CJ6bpOOY4ytqjm6gIgOiVDiPAuaDVtnDrl1gAGT+Tf2oZnIXgL+j5y1B97a6nI89UEy22HlpgEIpHuc4BHxtB+/sIiwyHTxu93uZ+ngOuP9AGuljhqAhdbOnADKQiz1Dvtd/adpmavoXexuZ7h1twakhTexpqDl7OuZL7y3YUaQO0hm+5Xb+bODs9hyJcgea8iFsPa99GOQtruNrdLgUC91XRGmZ2k/yTWnd3ITOP3TVPdHLLSnL6ofMrCIUkJc5J4qJSQONexFA+C8LmFq7tNxQhjjXqmd46iNKndL6UXRMdotqkQUVBUTEQPeUyr2IcKGG7IGesGvabo70Tipy/HGDZ2B3DtFGi3xEoIsQqXghOBvDlX2YQkPV6st+ZEaAmxPTbd2GHW5fFY+18M3DS16xMfHqCUODGSeago5X4eGa2+gchnGBGlj15x60UWfs6hOKW4wVsGMx88OHMR7ubK96ybgzQ2rQQx3qEihC3pbTYEoxI9tIl8BmOg0/J0FYd5WJY8HK2Rrpz86r8ejCjBpU861CTBr6RTbCCkW6p5YfSVWCEu/Owl3s8aXvzaGYvNe9NV0YknI6O5KTc4yw47tvAhwKQFErT2u8tN10jnuUWGkA7NWkQZbhOpSqEjMAXAb0Ujxx8N4Lh6MihixTw0uaOvAuE618JkxaTK9bjJ7fuY5xN2miOxCFtdf2LkjDIA/oK+xaA/V6bu0xjdehaGhutrSMiT4qaHTFQ8BjqvJrYBmZddlafhQ0quTpL7KUkCzoJbAtlc5OjdnN1gpScWXZ1zi8/pqKGlladwktKAD03Z4roh9cuif3pq9GiH0cJ9yi4KdltGKn8QU5RkmqiNOCX5+egPDh+6n6SktrvWliR43BuXtMvaQytS/t+4xXft/N6Vxm/NjqYZK2Sm330j68UQPiNKz1XRGR+dJSh4Qd7Uno3JypShGRF0jQd1HxqI2Hu4pgdPWiRx+VZZ27V0AclAsZLWvB3VI7EdDrWztSh6W/74818xStor1zGY2psrXTUS4iXvL0Lv5RVCI31YZ0oReW4OPbRnyEfb/Vy753j2PmlE1JVMHsLPS3S4tufPa8cIDNWy3wKvXFso0dexMjc4mU0D0RZhu03Os8LaZqKC0gP8jqMvrjluxrGe/nvSc80Ks+mVtM7hpe0L/MCDDThKOltkcbozLFJ/8mA7DsVEUq8uQJLDzhdr2qw+LSeC6DnG6BeU3IUM8/SiopSQ9Kg8IXDw903Ol9yzYYUU0Nhd6LBH2Yrzb63wWqUmnbjpeQ1P3svlhRM2zrs9cl2OANsoBiY5I7W5KSRjncv3q88v/s6wTqpsULiJOGIkNjeAp1sOSv5umVEpkDNXHJYJPgTAy2ZitTNGggrnhPnPLqQe7JSPHplY+lTpCpZtBMfwzWk2GdlpBq+C+A8H3VO3E5K/GIBzStmBjcVY3LmxYnxrV6HWRMbsriZMZC5nofcknFR1dY6Jc7M2ai7t01eB/ctpo1QWkN1fXsd+oIB9HSLc0fEDE1AVXrxKs2JLojDRD8trYQLGdvWIrOHPx4PTNEZmLyjQO1vZpzRe7Il2GZ7aGcHVrHv9pgjpjtOay6aVooYK/v/YLLj17pgpBepU0v4WdQmdoejrUjLCgv8NYJwjzjKVuKy5CT2LQa8zIdA42T+tm1j2usmZMlj/uxrDEILlIMrtRzjLAqm3uyZRcRlOWONOgQM12EarS7CIjYPXBXETEg6a8599e5rBd8ZKZ6UKg1zna7Q8aYpW8/LlMKym7n9vlCbi6LfiPvSg/AeARHE9Ker4I7NeZACJHP67XhHL79asas2t/l2BzAgbcWAHkIaQl22ZCZ6SPm11zMdJmsT2EaBhFFqRaPh8r5dBLxiqkszqQ2pLy96LzJTZsTWfJIB95UyMJRK/xC0g3k/FQiO44xH1rQRpxtuUG/PbZs5+adsulNqW1CuzYXit2sxT+snZP+fd48Qowh4ejy/JfEOxdepaCqI5srnETtgDD1mR1jOcxKlBYb/JDDVGhCSYnxslKLh2U2KEwLMbpQMYGqC9lrdgUEj9NAghhLHXSC5hiVmNjpkyyaj5t84Hx7+89FY4+fTVeAd7hloz1L3cJePV4cwh4gnH+7CR7lfLDhK53bIjHdmJIsHsPR5toI//MfGcA2KXXXJagBFGBz3ialeQwGc8ju1buJw1U/ys+bIyjYdVhdtDGeiCKXyyJGAk+5tOphpSZQpt54HW5UKAxYn7ZoU/gXfVkHO81pPGynCoU+PPTsD38GP919WBKN6DAVdg43SsHXDdH2lidT7kpWZOZiDw7BY09QZNYrlYUK7e3NrSTikhnrxcgvukKEDaBRiRq8Oo7tc/4D0GchpNS2CLI4yl6TQEHejsQZZaLBZRzpW1nCGq6Ygl","tags":[{"name":"年度总结","slug":"年度总结","permalink":"http://tech.noexception.cn/tags/%E5%B9%B4%E5%BA%A6%E6%80%BB%E7%BB%93/"}]},{"title":"Docker 铸剑之路","date":"2019-12-28T16:00:00.000Z","path":"2019/12/29/docker-walking/","text":"天道酬勤 1. 从指定的镜像，运行一个容器： 命令：docker run -itd -p port:port -name 'container_name' image_name 参数解析： i: 可交互的容器 d: 在后台运行 t: 应该是允许分配一个 tty 窗口 p: 映射容器芋宿主机之间的端口 2. 在一个后台运行的容器，执行命令/进入交互界面并 exit 时，不会将容器停止： 执行命令： 命令：docker exec container_id_or_name want_to_exe_command 效果：会在指定的容器中执行指定的命令，并且将结果打印在控制台中 进入交互界面并且 exit 时，不会将容器停止： 命令：docker exec -it container_id_or_name /bin/bash 效果：进入指定容器的bash交互命令行，允许通过 exit 退出","tags":[{"name":"docker","slug":"docker","permalink":"http://tech.noexception.cn/tags/docker/"},{"name":"容器","slug":"容器","permalink":"http://tech.noexception.cn/tags/%E5%AE%B9%E5%99%A8/"}]},{"title":"中间件的常用命令汇总","date":"2019-12-28T16:00:00.000Z","path":"2019/12/29/middleware-usage/","text":"天道酬勤 启动ES：docker run -itd --name es -p 9200:9200 -p 9300:9300 -e “discovery.type=single-node” elasticsearch /bin/bash 启动消息队列：docker run -itd -p 9876:9876 rocketmqinc/rocketmq:4.2.0 Rocketmq 启动 NameServer: nohup sh bin/mqnamesrv &amp;; tail -f ~/logs/rocketmqlogs/namesrv.log 启动 Broker: nohup sh bin/mqbroker -n localhost:9876 &amp;; tail -f ~/logs/rocketmqlogs/broker.log 测试发送和接受消息： 发送消息： export NAMESRV_ADDR=localhost:9876; sh bin/tools.sh org.apache.rocketmq.example.quickstart.Producer 接受消息： sh bin/tools.sh org.apache.rocketmq.example.quickstart.Consumer 关闭服务： sh bin/mqshutdown broker // 停止 broker sh bin/mqshutdown namesrv // 停止 nameserver 查看集群情况： ./mqadmin clusterList -n 127.0.0.1:9876 查看 broker 状态: ./mqadmin brokerStatus -n 127.0.0.1:9876 -b 172.20.1.138:10911 查看 topic 列表： ./mqadmin topicList -n 127.0.0.1:9876 查看 topic 状态： ./mqadmin topicStatus -n 127.0.0.1:9876 -t MyTopic 查看 topic 路由： ./mqadmin topicRoute -n 127.0.0.1:9876 -t MyTopic","tags":[{"name":"中间件","slug":"中间件","permalink":"http://tech.noexception.cn/tags/%E4%B8%AD%E9%97%B4%E4%BB%B6/"}]},{"title":"一周总结（2019-09-23 ~ 2019-09-29）","date":"2019-09-26T15:22:56.000Z","path":"2019/09/26/2019-09-26/","text":"勤劳温柔，还善良 Incorrect Password! No content to display! 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","tags":[{"name":"日记","slug":"日记","permalink":"http://tech.noexception.cn/tags/%E6%97%A5%E8%AE%B0/"},{"name":"持续更新中","slug":"持续更新中","permalink":"http://tech.noexception.cn/tags/%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0%E4%B8%AD/"}]},{"title":"2019-05-28 ARTS 分享","date":"2019-05-28T08:23:00.000Z","path":"2019/05/28/arts-2019-05-28/","text":"天道酬勤 A——Algorithm 一道算法题 LeetCode 852. 山脉数组的顶峰索引 我们把符合下列属性的数组 A 称作山脉： A.length &gt;= 3 存在 0 &lt; i &lt; A.length - 1 使得 A[0] &lt; A[1] &lt; ... A[i-1] &lt; A[i] &gt; A[i+1] &gt; ... &gt; A[A.length - 1] 给定一个确定为山脉的数组，返回任何满足 上述公式的 i 的值。 提示： 3 &lt;= A.length &lt;= 10000 0 &lt;= A[i] &lt;= 10^6 A 是如上定义的山脉 解答： 思路： 这道题解题思路，就是找到整个数组最大的数字，在无序状态下使用二分法的话，会出现找到的不是真正的山峰的情况，如果需要重新排序，再使用二分法找到最大的元素的话，时间复杂度就多了一个 O(n) 得不偿失。使用一次遍历找到最大的元素是最快的也是符合题目要求的答案 123456789101112131415161718192021// 示例 1：// 输入：[0,1,0]// 输出：1// 示例 2：// 输入：[0,2,1,0]// 输出：1class Solution &#123; public int peakIndexInMountainArray(int[] A) &#123; int result = 0; int index = 0; for(int i=0; i&lt;A.length; i++)&#123; if(A[i]&gt;result)&#123; result = A[i]; index = i; &#125; &#125; return index; &#125;&#125; R——Review 阅读一篇英文文章 T——Tips 学习一个新技术点 Websocket 一、Websocket 介绍 Websocket 是什么： Websocket 是一种网络通信协议。RFC6455 定义了它的通信标准。 Websocket 是 HTML5 开始提供的一种在单个 TCP 连接上进行全双工通讯的协议。 Websocket 是一个 TCP 接口进行双向通信的技术，PUSH 技术类型。同时 Websocket 仍将基于 W3C 标准，目前为止，Chrome 和 Safari 的最新版本浏览器已经支持 Websocket 了。 ajax 轮询和 long pull 均可实现实时信息传递。 ajax 轮询的原理非常简单，让浏览器每隔几秒就发送一次请求，询问服务器是否有新信息。 long poll 其实原理跟 ajax 轮询差不多，都是采用轮询的方式，不过采取的是阻塞模型（一直打电话，没有收到就不挂电话），也就是说，客户端发起连接后，如果没消息，就一直不反悔 Response 给客户端。直到有消息才返回，返回完之后，客户端再次建立连接，周而复始。 场景： 最典型的的场景就是聊天室，如果使用 HTTP 协议的话，就只能轮询获取服务端有没有消息，而使用 Websocket 的话，服务端有新消息可以自动推送。 特点： **较少的控制开销。**在连接创建后，服务器和客户端之间交换数据时，用于协议控制的数据包头部相对较小。在不包含扩展的情况下，对于服务器到客户端的内容，此头部大小只有2至10字节（和数据包长度有关）；对于客户端到服务器的内容，此头部还需要加上额外的4字节的掩码。相对于HTTP请求每次都要携带完整的头部，此项开销显著减少了。 **更强的实时性。**由于协议是全双工的，所以服务器可以随时主动给客户端下发数据。相对于HTTP请求需要等待客户端发起请求服务端才能响应，延迟明显更少；即使是和Comet等类似的长轮询比较，其也能在短时间内更多次地传递数据。 **保持连接状态。**与HTTP不同的是，Websocket需要先创建连接，这就使得其成为一种有状态的协议，之后通信时可以省略部分状态信息，而HTTP请求可能需要在每个请求都携带状态信息（如身份认证等）。 **更好的二进制支持。**Websocket定义了二进制帧，相对HTTP，可以更轻松地处理二进制内容。可以支持扩展。Websocket定义了扩展，用户可以扩展协议、实现部分自定义的子协议，如部分浏览器支持压缩等。 **更好的压缩效果。**相对于HTTP压缩，Websocket在适当的扩展支持下，可以沿用之前内容的上下文，在传递类似的数据时，可以显著地提高压缩率。 二、Stomp 和 Websocket STOMP（Simple Text Orientated Messaging Protocol），简单文本定向消息协议，它提供了一个可互操作的连接格式，允许 STOMP 客户端与任意 STO,P 消息代理（Broker）进行交互。STOMP 协议由于设计简单，易于开发客户端，因此在多种语言和多种平台上得到了广泛的应用。 STOMP 协议分为客户端和服务端： STOMP 服务端 STOMP服务端被设计为客户端可以向其发送消息的一组目标地址。STOMP协议并没有规定目标地址的格式，它由使用协议的应用自己来定义。例如，/topic/a、/queue/a、queue-a对于STOMP协议来说都是正确的。应用可以自己规定不同的格式以此来表明不同格式代表的含义。比如应用自己可以定义以/topic打头的为发布订阅模式，消息会被所有消费者客户端收到，以/user开头的为点对点模式，只会被一个消费者客户端收到。 STOMP 客户端 对于STOMP协议来说，客户端会扮演下列两种角色的任意一种： 作为生产者，通过 SEND 帧发送消息到指定的地址； 作为消费者，通过发送 SUBSCRIBE 帧到已知地址来进行消息订阅，而当生产者发送消息到这个订阅地址后，订阅该地址的其他消费者会受到通过 MESSAGE 帧受到该消息。 实际上，WebSocket结合STOMP相当于构建了一个消息分发队列，客户端可以在上述两个角色间转换，订阅机制保证了一个客户端消息可以通过服务器广播到多个其他客户端，作为生产者，又可以通过服务器来发送点对点消息。 STOMP 帧结构 一个 STOMP 帧有三部分组成： 命令、Header（头信息）、Body（消息体）。 命令使用UTF-8编码格式，命令有SEND、SUBSCRIBE、MESSAGE、CONNECT、CONNECTED等。 Header也使用UTF-8编码格式，它类似HTTP的Header，有content-length、content-type等。 Body可以是二进制也可以是文本，Body与Header间通过一个空行（EOL）来分隔。 123456789COMMANDheader1:value1header2:value2Body^@其中，^@表示行结束符。 1234567891011SENDdestination:/broker/roomId/1content-length:57&#123;\"type\":\"OUT\",\"content\":\"ossxxxxx-wq-yyyyyyyy\"&#125;// 第 1 行：表明此帧为SEND帧，是COMMAND字段。// 第 2 行：Header字段，消息要发送的目的地址，是相对地址。// 第 3 行：Header字段，消息体字符长度。// 第 4 行：空行，间隔Header与Body。// 第 5 行：消息体，为自定义的JSON结构。 三、Webcocket 事件 事件 事件处理程序 描述 open Socket onopen 连接建立时触发 message Socket onopen 客户端接收服务端数据时触发 error Socket onerror 通讯发生错误时触发 close Socket onclose 连接关闭时触发 一个页面使用 Websocket 的示例： 123456789101112131415var ws = new WebSocket(\"ws://localhost:8080\");ws.onopen = function(evt) &#123; console.log(\"Connection open ...\"); ws.send(\"Hello WebSockets!\");&#125;;ws.onmessage = function(evt) &#123;console.log( \"Received Message: \" + evt.data);ws.close();&#125;;ws.onclose = function(evt) &#123;console.log(\"Connection closed.\");&#125;; 四、Spring Boot 与 Websocket 整合(Spring Boot Websocket 聊天室) 聊天室功能 支持用户加入聊天室，对应到 Websocket 技术就是建立连接 onopen； 支持用户退出聊天室，对应到 Websocket 技术就是关闭连接 onclose； 支持用户在聊天室发送消息，对应到 Websocket 技术就是调用 onmessage 发送消息； 支持异常时提示，对应到 Websocket 技术 onerror。 页面开发 前端使用 Bootstrap 渲染页面，页面内容如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;chat room websocket&lt;/title&gt; &lt;link rel=\"stylesheet\" href=\"bootstrap.min.css\"&gt; &lt;script src=\"jquery-3.2.1.min.js\" &gt;&lt;/script&gt;&lt;/head&gt;&lt;body class=\"container\" style=\"width: 60%\"&gt;&lt;div class=\"form-group\" &gt;&lt;/br&gt; &lt;h5&gt;聊天室&lt;/h5&gt; &lt;textarea id=\"message_content\" class=\"form-control\" readonly=\"readonly\" cols=\"50\" rows=\"10\"&gt;&lt;/textarea&gt;&lt;/div&gt;&lt;div class=\"form-group\" &gt; &lt;label for=\"in_user_name\"&gt;用户姓名 &amp;nbsp;&lt;/label&gt; &lt;input id=\"in_user_name\" value=\"\" class=\"form-control\" /&gt;&lt;/br&gt; &lt;button id=\"user_join\" class=\"btn btn-success\" &gt;加入聊天室&lt;/button&gt; &lt;button id=\"user_exit\" class=\"btn btn-warning\" &gt;离开聊天室&lt;/button&gt;&lt;/div&gt;&lt;div class=\"form-group\" &gt; &lt;label for=\"in_room_msg\" &gt;群发消息 &amp;nbsp;&lt;/label&gt; &lt;input id=\"in_room_msg\" value=\"\" class=\"form-control\" /&gt;&lt;/br&gt; &lt;button id=\"user_send_all\" class=\"btn btn-info\" &gt;发送消息&lt;/button&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;&lt;!-- 最上面使用textarea画一个对话框，用来显示聊天室的内容；中间部分添加用户加入聊天室和离开聊天室的按钮，按钮上面是输入用户名的入口；页面最下面添加发送消息的入口， --&gt;&lt;!-- 页面中添加 Websocket 通讯代码： --&gt;&lt;script type=\"text/javascript\"&gt; $(document).ready(function()&#123; var urlPrefix ='ws://localhost:8080/chat-room/'; var ws = null; $('#user_join').click(function()&#123; var username = $('#in_user_name').val(); var url = urlPrefix + username; ws = new WebSocket(url); ws.onopen = function () &#123; console.log(\"建立 websocket 连接...\"); &#125;; ws.onmessage = function(event)&#123; //服务端发送的消息 $('#message_content').append(event.data+'\\n'); &#125;; ws.onclose = function()&#123; $('#message_content').append('用户['+username+'] 已经离开聊天室!'); console.log(\"关闭 websocket 连接...\"); &#125; &#125;); //客户端发送消息到服务器 $('#user_send_all').click(function()&#123; var msg = $('#in_room_msg').val(); if(ws)&#123; ws.send(msg); &#125; &#125;); // 退出聊天室 $('#user_exit').click(function()&#123; if(ws)&#123; ws.close(); &#125; &#125;); &#125;)&lt;/script&gt;&lt;!-- 主要是监听三个按钮的点击事件，当用户登录、离开、发送消息是调用对应的WebSocket事件，将信息传送给服务端。同时打开页面时创建了WebSocket对象，页面会监控WebSocket事件，如果后端服务和前端通讯室将对应的信息展示在页面。 --&gt; 服务端开发 添加依赖 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-websocket&lt;/artifactId&gt;&lt;/dependency&gt; 启动类 启动类需要添加 @EnableWebSocket 开启 WebSocket 功能。 123456789101112131415@EnableWebSocket@SpringBootApplicationpublic class WebSocketApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(WebSocketApplication.class, args); &#125; @Bean public ServerEndpointExporter serverEndpointExporter() &#123; return new ServerEndpointExporter(); &#125;&#125; 请求接收 在创建服务端消息接收功能之前，先创建一个WebSocketUtils工具类，用来存储聊天室在线的用户信息，以及发送消息的功能。定义全局变量ONLINE_USER_SESSIONS用来存储在线用户，使用ConcurrentHashMap提升高并发时效率。 12345678910111213141516171819202122232425262728293031@Slf4jpublic final class WebSocketUtils &#123; // 存储 websocket session public static final Map&lt;String, Session&gt; ONLINE_USER_SESSIONS = new ConcurrentHashMap&lt;&gt;(); public static void sendMessage(Session session, String message) &#123; if (session == null) &#123; return; &#125; final RemoteEndpoint.Basic basic = session.getBasicRemote(); if (basic == null) &#123; return; &#125; try &#123; basic.sendText(message); &#125; catch (IOException e) &#123; log.error(\"sendMessage IOException \", e); &#125; &#125; public static void sendMessageAll(String message) &#123; ONLINE_USER_SESSIONS.forEach((sessionId, session) -&gt; sendMessage(session, message)); &#125;&#125; Controller 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253@Slf4j@RestController@ServerEndpoint(\"/chat-room/&#123;username&#125;\")public class ChatRoomServerEndpoint&#123; @OnOpen public void openSession(@PathParam(\"username\") String username, Session session) &#123; ONLINE_USER_SESSIONS.put(username, session); String message = \"欢迎用户[\" + username + \"]来到聊天室\"; log.info(\"用户登录 : &#123;&#125;\", message); sendMessageAll(message); &#125; @OnMessage public void onMessage(@PathParam(\"username\") String username, String message) &#123; log.info(\"发送消息 : \"+message); sendMessageAll(\"用户[\" + username + \"] : \" + message); &#125; @OnClose public void onClose(@PathParam(\"username\") String username, Session session) &#123; // 当前的Session移除 ONLINE_USER_SESSIONS.remove(username); // 通知其他人当前用户已经离开聊天室了 sendMessageAll(\"用户[\" + username + \"]已经离开聊天室\"); try &#123; session.close(); &#125; catch (IOException e) &#123; log.error(\"onClose excepiton\", e); &#125; &#125; @OnError public void onError(Session session, Throwable throwable) &#123; try &#123; session.close(); &#125; catch (IOException e) &#123; log.error(\"onError excepiton\", e); &#125; log.info(\"Throwable msg &#123;&#125;\", throwable.getMessage()); &#125;&#125; 接受类上需要添加@ServerEndpoint(&quot;url&quot;)代表监听此地址的 WebSocket 信息。 @OnOpen注解和前端的onopen事件一致，表示用户建立连接时触发。 @OnMessage监听发送消息的事件。 @OnClose监听用户断开连接事件。 @OnError事件，可以在此方法内记录下错误的异常信息，并关闭用户连接。 S——Share 分享一篇有观点和思考的技术文章 https://coolshell.cn/articles/19271.html","tags":[{"name":"ARTS","slug":"ARTS","permalink":"http://tech.noexception.cn/tags/ARTS/"},{"name":"打卡","slug":"打卡","permalink":"http://tech.noexception.cn/tags/%E6%89%93%E5%8D%A1/"}]},{"title":"ARTS 每周打卡记录——2019/03/30","date":"2019-03-30T13:09:40.000Z","path":"2019/03/30/arts1/","text":"路漫漫其修远兮，吾将上下而求索 ARTS是什么？ Algorithm：每周至少做一个leetcode的算法题； Review：阅读并点评至少一篇英文技术文章； Tip/Techni：学习至少一个技术技巧； Share：分享一篇有观点和思考的技术文章。 1. Algorithms LeetCode 题目： 计算给定二叉树的所有左叶子之和。 1234567 3 &#x2F; \\ 9 20 &#x2F; \\ 15 7在这个二叉树中，有两个左叶子，分别是 9 和 15，所以返回 24 解答： 123456789101112131415161718192021222324/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public int sumOfLeftLeaves(TreeNode root) &#123; return sumOfLeft(root, false); &#125; private int sumOfLeft(TreeNode root, Boolean flag)&#123; if(root == null)&#123; return 0; &#125; if(root.left == null &amp;&amp; root.right == null &amp;&amp; flag == true)&#123; return root.val; &#125; return sumOfLeft(root.left, true) + sumOfLeft(root.right, false); &#125;&#125; 2. Review 死活打不开外国网站…暂时看看国内文章，以及自己的一些观点吧 淘宝宣布直播计划：今年培育200个销售额过亿直播间 我的观点，线上购物 + 直播会很火，容易激发路人的购物欲望。 3. Tips 在阿里飞冰的文档里面看到的一些小规范： 提交 commti 的类型，包括以下几种 feat: 新功能 fix: 修复问题 docs: 修改文档 style: 修改代码格式，不影响代码逻辑 refactor: 重构代码，理论上不影响现有功能 perf: 提升性能 test: 增加修改测试用例 chore: 修改工具相关（包括但不限于文档、代码生成等） deps: 升级依赖 这些小规范，有一个好处，在看 git log 的时候，很清晰明了的知道自己和其他人修改了什么内容。 4. Share Spring Autowired 与 Resource 的区别 @Resource 和 @Autowired 都是做 bean 的注入时使用，其实 @Resource 并不是 Spring 的注解，它的包是 javax.annotation.Resource, 需要导入，但是 Spring 支持该注解的注入。 共同点 两者都可以卸载字段和 setter 方法上。两者如果都写在字段上，那么就不需要再写 setter 方法。 不同点 @Autowired @Autowired为 Spring 提供的注解，需要导入包org.springframework.beans.factory.annotation.Autowired;只按照byType注入。 12345678910public class TestServiceImpl &#123; // 下面两种@Autowired只要使用一种即可 @Autowired private UserDao userDao; // 用于字段上 @Autowired public void setUserDao(UserDao userDao) &#123; // 用于属性的方法上 this.userDao = userDao; &#125;&#125; @Autowired注解是按照类型（byType）装配依赖对象，默认情况下它要求依赖对象必须存在，如果允许 null 值，可以设置它的 required 属性为 false。如果我们想使用按照名称（byName）来装配，可以结合@Qualifier注解一起使用。 12345public class TestServiceImpl&#123; @Autowired @Qualified(\"userDao\") private UserDao userDao;&#125; @Resource - `@Resource`默认按照 ByName 自动注入，由 J2EE 提供，需要导入包`javax.annotation.Resource`。`@Resource`有两个重要的属性：name 和 type，而 Spring 将`@Resource`注解的 name 属性解析为 bean 的名字，而 type 属性则解析为 bean 的类型。所以，如果使用 name 属性，则使用 byName 的自动注入策略，而使用 type 属性时则使用 byType 自动注入策略。如果既不制定 name 也不制定 type 属性，这时将通过反射机制使用 byName 自动注入策略。 12345678910public class TestServiceImpl &#123; // 下面两种@Resource只要使用一种即可 @Resource(name=\"userDao\") private UserDao userDao; // 用于字段上 @Resource(name=\"userDao\") public void setUserDao(UserDao userDao) &#123; // 用于属性的setter方法上 this.userDao = userDao; &#125;&#125; - **注**：最好是将`@Resource`放在 setter 方法上，因为这样更符合面向对象的思想，通过 set、get 去操作属性，而不是直接去操作属性。 @Resource 装配顺序： 如果同时指定了 name 和 type，则从 Spring 上下文中找到唯一匹配的 bean 进行装配，找不到则抛出异常。 如果指定了 name，则从上下文中查找名称（id）匹配的 bean 进行装配，找不到则抛出异常。 如果指定了 type，则从上下文中找到类似匹配的唯一 bean 进行装配，找不到或是找到多个，都会抛出异常。 如果既没有指定 name，又没有指定 type，则自动按照 byName 方式进行装配；如果没有匹配，则退回一个原始类型进行匹配，如果匹配则自动装配。 @Resource的作用相当于@Autowired，只不过@Autowired按照 byName 自动注入。","tags":[{"name":"ARTS 打卡","slug":"ARTS-打卡","permalink":"http://tech.noexception.cn/tags/ARTS-%E6%89%93%E5%8D%A1/"}]},{"title":"2019新年计划","date":"2019-01-06T04:54:15.000Z","path":"2019/01/06/2019first/","text":"勤劳温柔，还善良 Incorrect Password! No content to display! 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","tags":[{"name":"新年计划","slug":"新年计划","permalink":"http://tech.noexception.cn/tags/%E6%96%B0%E5%B9%B4%E8%AE%A1%E5%88%92/"},{"name":"算旧账","slug":"算旧账","permalink":"http://tech.noexception.cn/tags/%E7%AE%97%E6%97%A7%E8%B4%A6/"}]},{"title":"丢失的文章记录","date":"2018-10-01T05:50:44.000Z","path":"2018/10/01/logbefore/","text":"世界上最美丽的人是谁. Incorrect Password! No content to display! U2FsdGVkX19nMgzMYc/xc6BoYSGHCKAqkbX6CdRtlI1cyJvmf7wuD9C9iLB4nZ9Ky62RtwhLaEB+dm0Uh/LrX4uAxWW2Pvr59LlfTGKjEo6yYxbwBMvIzrFNcnBxR3ZFvJq8SJrn0U7odSCzsOrRp4t3/v937/0t8Y5WgnRUaGfdHBF+csrEhJgyG45Rt+O/nKG/wbHIp+93SU422xuqTpxuUVqvOYfVsau6pB1PmV3g6RpiOA9oaA03eygrPOkm1ws5DaZVs3mzh2CcDTtnB2ABH0aIAPEW/Yo37CRswKbQJXRRBjw49Ot3kh97fz9ctprUBmSyMD7KnZjwSfVRcXOp+2Q5fbDIDEcDXTIEUxPQuuU5JYQna8YV1tmyZsG8aHKqw0Ald/y2kbVhSPXpP95HwIyUViFddJiMwqtMz2qM0nVNHXVxQ85gUMyEWFGIi9h9PIWGq+HYBcBwc7HGafAg9IzuKdUohqzt+idd+tamUQt8zO1xpLBlrl1A1VnzRIDyd8tOwy5FwrsoP129o4qFMQ98Fslvau3M6Sj5ZyvlCvArTVnwz4+Kss0YPpr/AFhrB2KgJ3iHXQMKIiz9cd0/nrgOJKzB6Xp8Z9VACLmjj41+Q1Y30ikvkoz96Y1jEnHGID9d8P4HevKiaITiJR9DUAN/LLdPhID90bBM6PGoK9eyYxMN+V4G44W2Pn+FW4LdCKuYcU6wBmsvxpIWZrdMS16cMUoY3L/t8XVxUUiTR4AjWeJkkbamNAXr8D42uSMmjLc3ZwrxeQfredsOfhIEK7JkRCnER1kn7Sm009sGDbevSTPs7vH2KFhTspBH77+oxk89SC+KaBwz0oR8EK2EfDBUh8PBrXa/MEt/7tQn8s9EM4va364YNOZyiGppJ0zejoIBWDNjeBWZqeGMwVa9qjp+RYtpdUTBLKu+WyAbaAWXeUbyH/N+1N9u6AUULCEM6BGAiHOIrZOagEI2EzeFGYgaH2+sbZH/MbZIRwzqUAQBHSHEIGr9Vrx1kZArBkRW50W4v+qYLAaW659h5fVPIO1XWZzrwiOgEuPQnk9Lvev0xwv7l4ClwLS2KiMn8sBf6gyqZpsmTvSH/qOMWH56eANPRXVi/XLbmNl61xzjnerGwuXJAwWYY9z5tHvYIcKkuN+Au0U9v9HCuvOMtqn+/J/kYUrCdwVW3X0L9IhVK9dg156wvzN/zWDWuO4YBEN/OEu6zwbmpKc4IuaFoXEVlE4hC1JiB0uBn8NnhhahZrLVG76t1CrkeXBO5bu2mR16TVkkg9FMUv17ThOyix9rfaij57hPeDSNjwQdIzDNq6EW0Lg9zDZnRCV8xl0GSbYwYs7wXVgzuQBV3sPOhe/XVqR6FcfRkP5Ut5wh1K2+KbTMh1IJCq/RWmd5+zjlygPLQcmSIHymIeM/NGJZr46sTDqlc2vq8uWhrqkHky47tfJiaXxv3mVVhWByxs3H","tags":[]},{"title":"SQL 特性","date":"2017-04-13T11:17:19.000Z","path":"2017/04/13/SQLAdavance/","text":"关于高级 SQL 特性的读书笔记整理 约束 约束(constraint)：管理如何插入或处理数据库数据的规则。 主键 主键是一种特殊的约束，用来保证一列中的值是唯一的，而且永不改动。 主键要满足的条件： 任意两行的主键值都不同。 每行都具有一个主键值（即列中不允许 NULL 值） 包含主键值的列从不修改或更新。 主键值不能重用。如果表中删除某一行，其主键值不分配给新行。 1234567891011-- 在建表时定义主键：CREATE TABLE tablename( cum1 CHAR(10) NOT NULL PRIMARY KEY, cum2 CHAR(10) NOT NULL);-- 定于主键的第二种方法：ALTER TABLE tablename CONSTRAINT PRIMARY KEY (cum1);-- 注意：在 SQLite 中不允许使用 ALTER TABLE 定义键，要求在初始的 CREATE TABLE 语句中定义它们。 外键 外键是表中的一列，其值必须列在另一表中的主键中。外键是保证引用完整性的极其重要的部分。 《SQL 必知必会》 中的例子： Orders 表将录入到系统的每个订单作为一行包含其中。顾客信息存储在 Customers 表中。 Orders 表中订单通过顾客 ID 与 Customers 表中的特定行相关联。顾客 ID 为 Customers 表的主键，每个顾客都有唯一的 ID。订单号为 Orders 表的主键，每个订单都有唯一的订单号。Order 表中顾客 ID 列的值不一定是唯一的。如果某个顾客有多个订单，则有多个行具有相同的顾客 ID （虽然每个订单都有不同的订单号）。同事，Orders 表中顾客 ID 列的合法值为 Customers 表中顾客的 ID。 123456789101112-- 在建表语句中定义外键：CREATE TABLE Orders( order_num INTEGER NOT NULL PRIMARY KEY, order_date DATETIME NOT NULL, cust_id CHAR(10) NOT NULL REFERENCES Customers(cust_id));-- 在 ALTER TABLE 语句中用 CONSTRAINT 语法来完成：ALTER TABLE OrdersADD CONSTRAINTFOREIGN KEY (cust_id) REFERENCES Customers (cust_id) 外键有助于防止意外删除： 在定义外键后，DBMS 不允许删除在另一个表中具有关联行的行。例如不能删除关联订单的顾客。删除顾客的唯一方法是首先删除相关订单。由于需要一系列的删除，因而利用外键可以防止意外删除数据。 有的 DBMS 支持成为级联删除的特性。如果启用，该特性在从一个表中删除行时删除所有相关的数据。 唯一约束 唯一约束用来保证一列（或一组列）中的数据时唯一的。 唯一约束与主键的区别： 表可包含多个唯一约束，但每个表只允许一个主键。 唯一约束列可包含 NULL 值。 唯一约束列可修改和更新。 唯一约束列的值可重复使用。 与主键不一样，唯一约束不能用来定义外键。 语法： 同其他约束的语法。关键字 UNIQUE。 检查约束 检查约束用来保证一列（或一组列）中的数据满足一组指定的条件。 检查约束的常见用途： **检查最大或最小值。**例如，防止0个物品的订单。 **指定范围。**例如保证发货日期大于等于今天的日期，但不超过今天起一年后的日期。 **只允许特定的值。**例如，在性别字段中只允许 M 或 F。 12345678910111213-- 在建表语句中定义检查约束：-- 保证 quantity 大于 0.CREATE TABLE OrderItems( order_num INTEGER NOT NULL, order_item INTEGER NOT NULL, prod_id INTEGER NOT NULL, quantity INTEGER NOT NULL CHECK (quantity &gt; 0), item_price MONEY NOT NULL);-- 检查名为 gender 的列只包含 M 或 F，可编写如下的 ALTER TABLE 语句：ADD CONSTRAINT CHECK (gender LIKE '[MF]') 索引 索引用来排序数据以加快搜索和排序操作的速度。 可以在一个或多个列上定义索引，使 DBMS 保存期内容的一个排过序的列表。在定义了索引后，DBMS 以使用书的索引类似的方法使用它。DBMS 搜索排过序的索引，找出匹配的位置，然后检索这些行。 创建索引前要注意： **索引改善检索操作的性能，但降低了数据插入、修改和删除的性能。**在执行这些操作时，DBMS 必须动态地更新索引 索引数据可能要占用大量的存储空间。 **并非所有数据都适合做索引。**取值不多的数据不如具有更多可能值的数据，能用过索引得到那么多的好处。 **索引用于数据过滤和数据排序。**如果你经常以某种特定的顺序排序数据，则该数据可能适合做索引。 可以在索引中定义多个列。 12345-- 创建索引：CREATE INDEX prod_name_indON Products (prod_name);-- 索引必须唯一命名。 触发器 触发器是特殊的存储过程，它在特定的数据库活动发生时自动执行。 与存储过程不一样，触发器与单个的表相关联。与 Orders 表上的 INSERT 操作相关联的触发器只在 Orders 表中插入行时执行。 约束的处理比触发器快，在可能的时候，应该尽量使用约束。","tags":[{"name":"约束","slug":"约束","permalink":"http://tech.noexception.cn/tags/%E7%BA%A6%E6%9D%9F/"},{"name":"索引","slug":"索引","permalink":"http://tech.noexception.cn/tags/%E7%B4%A2%E5%BC%95/"},{"name":"触发器","slug":"触发器","permalink":"http://tech.noexception.cn/tags/%E8%A7%A6%E5%8F%91%E5%99%A8/"}]},{"title":"事务处理","date":"2017-04-10T05:35:28.000Z","path":"2017/04/10/transactionprocessing/","text":"一篇关于事务处理的笔记。 事务处理 通过确保成批的 SQL 操作要么完全执行，要么完全不执行，来维护数据库的完整性。 利用事务处理，可以保证一组操作不会中途停止，它们要么完全执行，要么完全不执行。如果没有错误发生，整组语句提交到数据库表；如果发生错误，则进行回退，将数据库恢复到某个已知且安全的状态。 关键词： 事务( transaction )指一组 SQL 语句； 回退（rollback）指撤销指定 SQL 语句的过程； 提交（commit）指将未存储的 SQL 语句结果写入数据库表； 保留点（savepoint）指事务处理中设置的临时占位符，可以对它发布回退（与回退整个事务处理不同）。 可以回退的语句：INSERT、UPDATE、DELETE。 控制事务处理 事务处理的语法： START TRANSACTION 或 BEGIN ：开始一个新的事务； COMMIT：提交当前的事务，提交以后，无法回滚； ROLLBACK：回滚当前的事务，取消对表的操作； SET autocommit：为当前的会话打开或关闭 autocommit 模式，默认打开。 隐式地关闭 autocommit 模式，要用 START TRANSACTION 语句： 12345START TRANSACTION;SELECT @A:=SUM(salary) FROM table1 WHERE type=1;UPDATE table2 SET summary=@A WHERE type=1;COMMIT;-- 在 START TRANSACTION 中， autocommit 模式会暂时的为关闭状态，指导 COMMIT 或者 ROLLBACK 语句被执行。这是 autocommit 模式才会回到之前的状态。 ROLLBACK SQL 的 ROLLBACK 命令用来回退 SQL 语句。 在事务处理块中，DELETE 操作（SELECT 和 UPDATE 一样）并不是最终的结果。 COMMIT 隐式提交（implicit commit）：一般的 SQL 语句都是针对数据库表直接执行和编写的，即提交（写或保存）操作是自动进行的。 SAVEPOINT 使用简单的 ROLLBACK 和 COMMIT 语句，就可以写入或撤销整个事务。但是，只对简单的事务才能这样做，复杂的事务可能需要部分提交或回退。 要支持回退部分事务，必须在事务处理块中合适的位置放占位符。 123SAVEPOINT identifier;ROLLBACK TO identifier; SAVEPOINT 越多越好： 保留点越多，越能灵活地进行回退。","tags":[{"name":"事务","slug":"事务","permalink":"http://tech.noexception.cn/tags/%E4%BA%8B%E5%8A%A1/"}]},{"title":"MySQL 视图","date":"2017-04-09T10:38:49.000Z","path":"2017/04/09/MySQLView/","text":"关于 MySQL 的视图的笔记 视图 视图是虚拟的表。与包含数据的表不一样，视图只包含使用时动态检索数据的查询。它可以把查询包装秤一个虚拟表，就可以轻松地检索出相同的数据。视图不包含任何列或数据，包含的是一个查询。 视图是虚拟的表。它们包含的不是数据而是根据需要检索数据的查询。视图提供了一种封装 SELECT 语句的层次，可用来简化数据处理，重新格式化或保护基础数据。 使用视图 使用视图的好处： 重用 SQL 语句。 简化复杂的 SQL 操作。在编写查询后，可以方便地重用它而不必知道其基本查询细节。 使用表的一部分而不是整个表。 保护数据。可以授予用户访问表的特定部分的权限，而不是整个表的访问权限。 更改数据格式和表示。视图可返回与底层表的表示和格式不同的数据。 视图与表： 创建视图后，可以用与表相同的方式使用它们。例如：SELECT、过滤、排序、将视图与表或其他视图联接、添加更新数据等等。 视图是用来查看存储在别处数据的一种设施，本身不包含数据，因此返回的数据是从其他表中检索出来的。 性能问题，如上所述，若用多个联结和过滤创建了复杂的视图或者嵌套多层视图，性能会大幅度下降。在部署使用了大量视图的应用前，应该进行测试。 规则和限制 关于视图创建和使用最常见的规则和限制： 与表一样，视图必须唯一命名（不能给视图取与别的视图或表相同的名字）。 对于可以创建的视图数目没有限制。 创建视图，必须具有足够的访问权限。这些权限通常由数据库管理人员授予。 视图可以嵌套，即可以利用从其他视图中检索数据的查询来构造视图。所允许的嵌套层数在不同的 DBMS 中有所不同（嵌套视图可能会严重降低查询的性能，因此在产品环境中使用之前，应该对其进行全面测试）。 许多 DBMS 禁止在视图查询中使用 ORDER BY 字句（MySQL 中貌似没有限制）。 有些 DBMS 要求对返回的所有列进行命名，如果列是计算字段，则需要使用别名。 视图不能索引，也不能有关联的触发器或默认值。 有些 DBMS 把视图作为只读的查询，这表示可以从视图检索数据，但不能将数据写会底层表。（详情参阅具体的 DBMS 文档） 有些 DBMS 允许创建这样的视图，它不能进行导致行不再属于视图的插入或更新。例如有一个视图，只检索带有电子邮件地址的顾客。如果更新某个顾客，删除他的电子邮件地址，将使顾客不再属于视图。这是默认行为，而且是允许的，但有的 DBMS 可能会防止这种情况发生。 创建视图 创建视图语句： 12345CREATE VIEW viewname AS SELECT field_name1, field_name2, field_name3FROM table_name1, table_name2, table_name3WHERE table_name1.... = table_name2....AND table_name2.... = table_name3....; 删除视图语句：(覆盖或更新视图时，必须先删除它，然后再重新创建。) 1DROP VIEW viewname; 利用视图简化复杂的联结 创建不绑定特定数据的视图是一种好办法。扩展视图的范围不仅使得它能被重用，而且可能更有用。这样做不需要创建和维护多个类似视图。 1234567891011# 这是一个例子:create view ProductCustomers asselect cust_name, cust_contact, prod_idfrom Customers, Orders, OrderItemswhere Customers.cust_id = Orders.cust_idand OrderItems.order_num = Orders.order_num;select cust_name, cust_contactfrom ProductCustomerswhere prod_id = 'RGAN01'; 格式化检索出的数据 SELECT 约束全部使用。 MySQL 不支持+、||操作符来拼接值，检索出来的结果全为0，但是行数与所求的行数是相同的。要使用函数Concat()例如：(出处《SQL必知必会》) 123select Concat(vend_name, '(', vend_country, ')') from Vendors order by vend_name; 用视图过滤不想要的数据 123456789# 这是一个例子：create view CustomerEmailList as select cust_id, cust_name, cust_emailfrom Customerswhere cust_email is not null;select * from CustomersEmailList; 视图与计算字段 使用方法同表。 参考文献：《 SQL 必知必会》","tags":[{"name":"视图","slug":"视图","permalink":"http://tech.noexception.cn/tags/%E8%A7%86%E5%9B%BE/"}]},{"title":"Mysql 错误记录","date":"2017-04-09T06:42:55.000Z","path":"2017/04/09/MysqlError/","text":"1. Mysql远程连接问题 问题描述： 从一台linux客户款远程连接Mysql，出现错误代码ERROR 2003 (HY000): Can't connect to MySQL server on '***.***.***.***' (111) 问题分析： 网络连接问题。 排除，局域网内，均能相互ping通 配置文件中bind_address项 DNS解析的问题 直接用的是主机IP而非主机名，不存在解析错误的问题 解决方法： 编辑 MySQL 配置文件 my.cnf sudo vim /etc/mysql/my.cnf 找到bind-address = 127.0.0.1，用#号将其注释掉。 重启 MySQL 服务。 倘若在第一步的时候，没有在my.cnf中找到bind-address=127.0.0.1，则去/etc/mysql/mysql.conf.d/mysqld.cnf文件中寻找。 问题解决。 来源于StackOverflow","tags":[{"name":"Mysql","slug":"Mysql","permalink":"http://tech.noexception.cn/tags/Mysql/"},{"name":"Error","slug":"Error","permalink":"http://tech.noexception.cn/tags/Error/"}]},{"title":"消息队列和Celery","date":"2017-03-28T14:39:18.000Z","path":"2017/03/28/messagehandle/","text":"Beanstalkd Beanstalkd 的特点： 可持久化。 Beanstalkd 运行使用内存，但也提供了持久性支持。在启动的时候使用 -b 参数指定持久化目录，它会将所有的任务写入 binlog 文件。在发生断电等情况后，用同样的参数指定重启它，将恢复 binlog 中的内容。 任务超时重发。 消费者必须在预设的 TTR （Time To Run） 时间内发送 delete/release/bury 改变任务状态，否则它会认为消息处理失败，把任务交给别的消费者节点执行。 **支持任务预留。**如果任务因为某些原因无法执行，消费者可以把任务置为 buried 状态保留这些任务。 **支持分布式。**客户端可以实现和 Memcached 一样的分布式。 灵活设置任务过期和TTR时间。 job job 就是待异步执行的任务，也就是消息，是 Beanstalkd 中的基本单元。一个 job 通过生产者使用 put 命令时创建，然后被放在一个管道（tube）中。在整个生命周期中 job 可能有4个工作状态。 ready: 等待被取出并处理。 reserved: 如果 job 被消费者（worker）取出，将被此消费者预订，消费者将执行 job . delayed: 等待特定时间之后，状态再改为 ready 状态。 buried: 等待唤醒，通常在 job 处理失败时，会变成这个状态。 Beanstalkc Beanstalkd 借鉴了 Memcached 设计，它们的协议和使用方式的风格很像。本节使用 Beanstalkd 的 Python 客户端 Beanstalkc 演示 Beanstalkd 的用法 pip install PyYAML beanstalkc #安装","tags":[{"name":"Python","slug":"Python","permalink":"http://tech.noexception.cn/tags/Python/"},{"name":"Web开发","slug":"Web开发","permalink":"http://tech.noexception.cn/tags/Web%E5%BC%80%E5%8F%91/"}]},{"title":"Python系统管理——Supervisor","date":"2017-03-21T12:53:23.000Z","path":"2017/03/21/python-supervisor/","text":"Supervisor 组件 Supervisord : 服务端程序，它的主要功能是启动 Supervisord 服务及其管理的子进程，记录日志，重启崩溃的进程等。 Supervisorctl : 命令行客户端程序，它提供一个类似 Shell 的接口，通过 UNIX 域套接字或者 TCP/IP 套接字使用 XML_RPC 协议与 Supervisord 进程进行数据通信。它的主要功能就是管理（启动、关闭、重启、查看状态等）子进程。 Web Server : 实现了在界面上管理进程，还能查看进程日志和清除日志。Web Server 其实是通过 XML_RPC 来实现的，可以向 Supervisord 请求数据。它配置爱 [inet_http_server] 块里面。 XML_RPC 接口 : 可以通过XML-RPC 协议对 Web Server 进行远程调用，达到和 Supervisorctl 以及 Web Server 一样的管理功能。 配置 Supervisor Supervisor 的配置文件一般都叫 supervisord.conf。启动 Supervisord 的时候会按照如下路径寻找配置文件： 当前目录下的 supervisord.conf ($CWD/supervisord.conf)。 当前目录的 etc 目录下的 supervisord.conf （$CWD/etc/supervisord.conf） 相对于可执行文件 supervisord 的上一级的 etc 目录下的 supervisord.conf (…/etc/supervisord.conf)。 相对于可执行文件 supervisord 的上一级的 supervisord.conf （…/supervisord.conf） 可以使用 -c 选项指定不符合如上要求的配置文件路径 使用 Supervisor 分为三种：supervisorctl 命令行方式管理进程、通过 web 方式管理进程和通过 XML_RPC 接口来管理进程。","tags":[{"name":"Python","slug":"Python","permalink":"http://tech.noexception.cn/tags/Python/"},{"name":"系统管理","slug":"系统管理","permalink":"http://tech.noexception.cn/tags/%E7%B3%BB%E7%BB%9F%E7%AE%A1%E7%90%86/"}]},{"title":"关于 Flask 信号的一点小笔记","date":"2017-03-16T18:54:36.000Z","path":"2017/03/17/day0317/","text":"Flask中的信号及其含义 信号 信号通过发送发生在核心框架的其他地方或 Flask 扩展的动作时的通知来帮助你解耦应用。简而言之，信号允许特定的发送端通知订阅者发生了什么 订阅信号 使用 connect() 方法来订阅信号。该函数的第一个参数是信号发出时要调用的函数，第二个参数可选，用于确定信号的发送端。 使用 disconnect() 方法来退订。 对于所有的核心 Flask 信号，发送端都是发送信号的应用。当你订阅一个信号，请确保也提供一个发送端，除非你确实想监听全部应用的信号。这在你开发一个扩展的时候尤其正确。 创建信号 在定义的 Namespace 中命名信号。这也是大多时候推荐的做法： 12from blinker import Namespacemy_signals = Namespace() -创建信号： 1model_saved = mysignals.signal('model-saved') 这里使用唯一的信号名，简化调试。可以用 name 属性来访问信号名。 发送信号 调用 send() 方法，发出信号。 它接受发送端作为第一个参数，和一些推送到信号订阅者的可选关键字参数： 1234class Model(object): ... def save(self): model_saved.send(self) 永远尝试选择一个合适的发送端。如果你有一个发出信号的类，把 self 作为发送端。如果你从一个随记的函数发出信号，把 current_app._get_current_object() 作为发送端。 传递代理作为发送端： 永远不要向信号传递 current_app 作为发送端，使用 current_app._get_current_object() 作为替代。这样的原因是， current_app 是一个代理，而不是真正的对象。 信号与 Flask 的请求上下文 信号在接收时，完全支持请求上下文。上下文本地的变量在 request_started 和 request_finished 一贯可用，所以你可以信任 flask.g 和其他需要的东西。 基于装饰器的信号订阅 可以在 Blinker 1.1 中容易地用新的 connect_via() 装饰器订阅信号： 12345from flask import template_rendered@template_rendered.connect_via(app)def when_template_rendered(sender, template, context, **extra): print 'Template %s is rendered with %s' % (template.name, context) 核心信号 flask.template_rendered：模板渲染成功的时候发送，这个信号与模板实例template、上下文的字典一起用。 1234567def log_template_renders(sender, template, context, **extra): sender.logger.debug('Rendering template \"%s\" with context %s', template.name or 'string template', context)from flask import template_renderedtemplate_rendered.connect(log_template_renders, app) flask.request_started：建立请求上下文后，在请求处理开始前发送，订阅者可以用 request 之类的标准全局代理访问请求。 12345def log_request(sender, **extra): sender.logger.debug('Request context is set up')from flask import request_startedrequest_started.connect(log_request, app) flask.request_finished：在响应发送给客户端之前发送，可以传递 response 。 123456def log_response(sender, response, **extra): sender.logger.debug('Request context is about to close down.' 'Response: %s', response)from flask import request_finishedrequest_finished.connect(log_response, app) flask.got_request_exception：在请求处理中抛出异常时发送，异常本身会通过 exception 传递到订阅的函数。 12345def log_exception(sender, exception, **extra): sender.logger.debug('Got exception during processing: %s', exception)from flask import got_request_exceptiongot_request_exception.connect(log_exception, app) flask.request_tearing_down：在请求销毁时发送，它总是被调用，即使发生异常。 12345def close_db_connection(sender, **extra): session.close()from flask import request_tearing_downrequest_tearing_down.connect(close_db_connection, app) flask.appcontext_tearing_down：在应用上下文销毁时发送，它总是被调用，即使发生异常。 12345def close_db_connection(sender, **extra): session.close()from flask import request_tearing_downappcontext_tearing_down.connect(close_db_connection, app) flask.appcontext_pushed: 这个信号在应用上下文压入栈时发送。发送者是应用对象。这通常在单元测试中为了暂时地钩住信息比较有用。例如这可以用来提前在 g 对象上设置一些资源。 123456789101112131415from contextlib import contextmanagerfrom flask import appcontext_pushed@contextmanagerdef user_set(app, user): def handler(sender, **kwargs): g.user = user with appcontext_pushed.connected_to(handler, app): yield# 测试代码def test_user_me(self): with user_set(app, 'john'): c = app.test_client() resp = c.get('/user/me') assert resp.data == 'username=john' flask.appcontext_popped: 这个信号在应用上下文弹出栈时发送。发送者是应用对象。这通常在 appcontext_tearing_down 信号发送后发送 flask.message_flashed: 这个信号在应用对象闪现一个消息时发送。消息作为 message 命名参数发送，分类则是 category 参数。 12345recorded = []def record(sender, message, category, **extra): recorded.append((message, category))from flask import message_flashedmessage_flashed.connect(record, app)","tags":[{"name":"Flask","slug":"Flask","permalink":"http://tech.noexception.cn/tags/Flask/"},{"name":"信号","slug":"信号","permalink":"http://tech.noexception.cn/tags/%E4%BF%A1%E5%8F%B7/"}]},{"title":"Lxml随记","date":"2017-02-18T15:50:39.000Z","path":"2017/02/18/Lxml笔/","text":"简介： Lxml是基于libxml2解析库的Python封装。解析速度比Beautiful Soup 快，缺点就是安装麻烦。 CSS选择器： CSS选择器表示选择元素所使用的模式 示例： 选择所有标签：* 选择标签：a 选择所有class=&quot;link&quot;的元素：.link 选择class=&quot;link&quot;的标签：a.link 选择id=&quot;home&quot;的标签：a#home 选择父元素为标签的所有子标签：a &gt; span 选择标签内部的所有标签：a span 选择title属性为&quot;Home&quot;的所有标签：a[title=Home]","tags":[{"name":"Python","slug":"Python","permalink":"http://tech.noexception.cn/tags/Python/"},{"name":"爬虫","slug":"爬虫","permalink":"http://tech.noexception.cn/tags/%E7%88%AC%E8%99%AB/"}]},{"title":"2016年终总结","date":"2017-01-03T12:58:47.000Z","path":"2017/01/03/2016年终总结/","text":"勤劳温柔，还善良 Incorrect Password! No content to display! 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","tags":[{"name":"总结","slug":"总结","permalink":"http://tech.noexception.cn/tags/%E6%80%BB%E7%BB%93/"}]},{"title":"《C++ Primer》第八章小结","date":"2016-12-29T12:46:24.000Z","path":"2016/12/29/sumeryofchapter8/","text":"IO库小结 C++ 使用标准库类来处理面向流的输入和输出； iostream处理控制台IO fstream处理命名文件IO stringstream完成内存string的IO &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;类`fstream`和`stringstream`都是继承自类`iostream`的。输入类都继承自`istream`，输出类都继承自`ostream`。因此，可以在`istream`对象上执行的操作，也可在`ifstream`或`istringstream`对象上执行。继承自`ostream`的输出类也有类似情况。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;每个IO对象都维护一组条件状态，用来指出对象上是否可以进行IO操作。如果遇到了错误——例如在输入流上遇到了文件末尾，则对象的状态变为失效，所有后续输入操作都不能执行，直至错误被纠正。标准库提供了一组函数，用来设置和检测这些状态。","tags":[{"name":"C++","slug":"C","permalink":"http://tech.noexception.cn/tags/C/"}]},{"title":"CentOS7安装Mysql","date":"2016-11-15T12:32:21.000Z","path":"2016/11/15/CentOS7安装Mysql/","text":"CENTOS7默认的yum源没有mysql-server这个库，所以yum install -y mysql-server这个命令在CENTOS7中无法使用。 1. 安装： 12345wget http:&#x2F;&#x2F;repo.mysql.com&#x2F;mysql-community-release-el7-5.noarch.rpmsudo rpm -yvh mysql-community-release-el7-5.noarch.rpmyum updatesudo yum install mysql-serversudo systemctl start mysqld 2. 管理root密码 默认安装的mysql是没有密码的 12345678910#执行下面的命令，直接回车即可进入mysql终端mysql -u root -p#执行下面的命令给root用户设置密码set password for root@localhost&#x3D;password(&#39;123&#39;);#然后退出quit#再次登陆，需要密码进入mysql -u root -p#或者快捷方式进入mysql -uroot -p123 3. 设置Mysql的访问权限 设置所有ip可以访问这台mysql的命令，默认情况下只有本机能访问，对外是不公开的 12345678910111213grant all on *.* to &#39;root&#39;@&#39;%&#39; identified by &#39;123&#39; with grant option;flush privileges;#命令说明：grant all ：所有的权限用allon *.*：匹配库名.表名，*.*指的是允许所有的库和表被访问。&#39;root&#39;@&#39;%&#39;：用户名@IP，注意用户名和ip都要用单引号引起来ip这个地方，支持like通配，比如%dev，允许所有以dev结尾的域名访问%代表所有的ip&#39;123&#39;代表root密码 4. mysql有关的系统管理命令 CentOS7管理Mysql的启动和停止 123systemctl start mysqldsystemctl stop mysqldsystemctl status mysqld 转自：http://mp.weixin.qq.com/s?__biz=MzAxMzE4MDI0NQ==&amp;mid=2650335219&amp;idx=1&amp;sn=38abc805b96fb7d4f497a90f28f377c2&amp;chksm=83aacbc9b4dd42dfbf2be8b83155124aeafd490234a9bcfbb6a94fa255d455fe8d04b4467da6&amp;scene=4#wechat_redirect","tags":[{"name":"CentOS7","slug":"CentOS7","permalink":"http://tech.noexception.cn/tags/CentOS7/"},{"name":"Mysql","slug":"Mysql","permalink":"http://tech.noexception.cn/tags/Mysql/"}]},{"title":"数据结构与算法复习（一）","date":"2016-11-07T07:08:13.000Z","path":"2016/11/07/数据结构与算法复习（一）/","text":"本篇为复习数据结构与算法的第一篇 背包、队列和栈 API 泛型可迭代的基础集合数据类型的API 背包 public class Bag&lt;Item&gt; implements Iterable&lt;Item&gt; Bag() 创建一个空背包 void add(Item item) 添加一个元素 boolean isEmpty() 背包是否为空 int size() 背包中的元素数量 先进先出(FIFO)队列 public class Queue&lt;Item&gt; implements Iterable&lt;Item&gt; Queue() 创建空队列 void enqueue(Item item) 添加一个元素 Item dequeue() 删除最早添加的元素 boolean isEmpty() 队列是否为空 int size() 队列中的元素数量 下压(后进先出，LIFO)栈 public class Stack&lt;Item&gt; implements Iterable&lt;Item&gt; Stack() 创建一个空栈 void push(Item item) 添加一个元素 Item pop() 删除最近添加的元素 boolean isEmpty() 栈是否为空 int size() 栈中的元素数量 泛型 集合类的抽象数据类型的一个关键特性是我们应该可以用它们存储任意类型的数据。一种特别的Java机制能够做到这一点，它被成为泛型，也叫做参数化类型。 在每份API中，类名后的记号将Item定义为一个类型参数，它一个象征性的占位符，表示的是用例将会使用的某种具体数据类型。可以将Stack理解为某种元素的栈。 在创建栈时，用例会提供一种具体的数据类型：我们可以将Item替换为任意引用数据类型（Item出现的每个地方都是如此）。 自动装箱 类型参数必须被实例化为引用类型，因此Java有一种特殊机制来使泛型代码能够处理原始数据类型。123Stack&lt;Integer&gt; stack = new Stack&lt;Integer&gt;();stack.push(17); //自动装箱(int -&gt; Integer)int i = stack.pop(); //自动拆箱(Integer -&gt; int) 自动将一个原始数据类型转换为一个封装类型被成为自动装箱，自动将一个封装类型转换为一个原始数据类型被成为自动拆箱。 可迭代的集合类型 对于许多应用场景，用例的要求只是用某种方式处理集合中的每个元素，或者叫做迭代访问集合中的所有元素。 例如，假设用例在Queue中维护一个交易集合： 123456Queue&lt;Transaction&gt; collection = new Queue&lt;Transaction&gt;();//如果集合是可迭代的，用例用一行语句即可打印出交易的列表：for(Transaction t : collection)&#123; StdOUt.println(t);&#125;//这种语法叫做foreach语句：可以将for语句看做对于集合中的每个交易t(foreach)，执行一下代码断。 背包 背包市一种不支持从中删除元素的集合数据类型——它的目的就是帮助用例手机元素并迭代便利所有收集到的元素（用例也可以检查背包是否为空或者获取背包中的元素数量）。 12345678910111213141516171819202122public class Stats&#123; public static void main(String[] args)&#123; Bag&lt;Double&gt; numbers = new Bag&lt;Double&gt;(); while(!StdIn.isEmpty()) numbers.add(StdIn.readDouble()); int N = numbers.size(); double sum = 0.0; for(double x: numbers)&#123; sum+=x; &#125; double mean = sum/N; sum = 0.0; for(double x : numbers)&#123; sum += (x-mean)*(x-mean); &#125; double std = Math.sqrt(sum/(N-1)); StdOUt.printf(\"Mean: %.2f\\n\", mean); StdOUt.printf(\"Std dev: %.2f\\n\", std); &#125;&#125; 上述的Stats类是Bag的一个典型用例。它的任务是简单的计算标准输入中的所有double值的平均值和样本标准差。如果标准输入中有N个数字，那么平均值为它们的和除以N，样本标准差为每个值和平均值只差的平方之和除以N-1之后的平方根。 在这些计算中，数的计算顺序和结果无关，因此我们将它们保存在一个Bag对象中并使用foreach语法来计算每个和。 **注意:**不需要保存所有的数也可以计算标准差（就像我们在Accumulator中计算平均值那样）。 先进先出队列 先进先出队列（或简称队列）是一种基于先进先出（FIFO）策略的集合类型。 在提到公平时大多数热的第一个想法就是应该优先服务等待时间最久的人，这正是先进先出策略的准则。队列是许多日常现象的自然模型，它是无数应用程序的核心。 当用例使用foreach语句迭代访问队列中的元素时，元素的处理顺序就是它们被添加到队列中的顺序。 下压栈 下压栈（或简称栈）是一种基于后进先出（LIFO）策略的集合类型。 当你的邮件在桌上放成一叠时，使用的就是栈。 这种策略的好处是我们能够及时看到感兴趣的邮件，坏处是如果你不把栈清空，某些较早的邮件可能永远不会被阅读。 当用例使用foreach语句迭代遍历栈中的元素时，元素处理顺序和它们被压入栈的顺序正好相反。 在应用程序中使用栈迭代器的一个典型原因是在用集合保存元素的同时颠倒他们的相对顺序。 12345678910public class Reserse&#123; public static void main(String[] args)&#123; Stack&lt;Integer&gt; stack; stack = new Stack&lt;Integer&gt;(); while(!StdIn.isEmpty()) stack.push(StdIn.readInt()); for(int i : stack) StdOUt.println(i); &#125;&#125; 算术表达式求值 E.W.Dijkstra在20世纪60年代发明了一个非常简单的算法，用两个栈（一个用于保存运算符，一个用于保存操作数）完成了这个任务，其实现过程如下： 123456789101112131415161718192021222324252627282930//Dijkstra的双栈算术表达式求值算法public class Evaluate&#123; public static void main(String[] args)&#123; Stack&lt;String&gt; ops = new Stack&lt;String&gt;(); Stack&lt;Double&gt; vals = new Stack&lt;Double&gt;(); while(!StdIn.isEmpty())&#123; //读取字符，如果是运算符则压入栈 String s = StdIn.readString(); if(s.equals(\"(\")); else if(s.equals(\"+\")) ops.push(s); else if(s.equals(\"-\")) ops.push(s); else if(s.equals(\"*\")) ops.push(s); else if(s.equals(\"/\")) ops.push(s); else if(s.equals(\"sqrt\")) ops.push(s); else if(s.equals(\")\"))&#123; //如果字符为“)”，弹出运算符和操作数，计算结果并压入栈 String op = ops.pop(); double v = vals.pop(); if (op.equals(\"+\")) v = vals.pop() + v; else if (op.equals(\"-\")) v = vals.pop() - v; else if (op.equals(\"*\")) v = vals.pop() * v; else if (op.equals(\"/\")) v = vals.pop() / v; else if (op.equals(\"sqrt\")) v = Math.sqrt(v); vals.push(v); &#125; //如果字符既非运算符也不是括号，将它作为double值压入栈 else vals.push(Double.parseDouble(s)); &#125; StdOut.println(vals.pop()); &#125;&#125; 这段Stack的用例使用了两个栈来计算表达式的值。它展示了一种重要的计算模型：将一个字符串解释为一段程序并执行该程序得到结果。有了泛型，我们只需实现Stack一次即可使用String值的栈和Double值的栈。 表达式由括号、运算符和操作数（数组）组成。我们根据一下4种情况从左到右逐个将这些实体送入栈处理： 将操作数压入操作数栈； 将运算符压入运算符栈； 忽略左括号； 在遇到右括号时，弹出一个运算符，弹出所需数量的操作数，并将运算符和操作数的运算结果压入操作数栈中。 未完待续……","tags":[{"name":"背包","slug":"背包","permalink":"http://tech.noexception.cn/tags/%E8%83%8C%E5%8C%85/"},{"name":"队列","slug":"队列","permalink":"http://tech.noexception.cn/tags/%E9%98%9F%E5%88%97/"},{"name":"栈","slug":"栈","permalink":"http://tech.noexception.cn/tags/%E6%A0%88/"}]},{"title":"MathJax相关","date":"2016-11-05T07:14:41.000Z","path":"2016/11/05/MathJax相关-md/","text":"本篇记录了一些和MathJax相关的东西，以及数学公式书写的规则还有一些常用的希腊字母 希腊字母 字母名称 大写 Markdown原文 小写 Markdown原文 alpha AAA A α\\alphaα \\alpha beta BBB B β\\betaβ \\beta gamma Γ\\GammaΓ \\Gamma γ\\gammaγ \\gamma delta Δ\\DeltaΔ \\Delta δ\\deltaδ \\delta epsilon EEE E ϵ\\epsilonϵ \\epsilon ε\\varepsilonε \\varepsilon zeta ZZZ Z ζ\\zetaζ \\zeta eta HHH H η\\etaη \\eta theta Θ\\ThetaΘ \\Theta θ\\thetaθ \\theta iota III I ι\\iotaι \\iota kappa KKK K κ\\kappaκ \\kappa lambda Λ\\LambdaΛ \\Lambda λ\\lambdaλ \\lambda mu MMM M μ\\muμ \\mu nu NNN N ν\\nuν \\nu xi Ξ\\XiΞ \\Xi ξ\\xiξ \\xi omicron OOO O ο\\omicronο \\omicron pi Π\\PiΠ \\Pi π\\piπ \\pi rho PPP P ρ\\rhoρ \\rho sigma Σ\\SigmaΣ \\Sigma σ\\sigmaσ \\sigma tau TTT T τ\\tauτ \\tau upsilon Υ\\UpsilonΥ \\Upsilon υ\\upsilonυ \\upsilon phi Φ\\PhiΦ \\Phi ϕ\\phiϕ \\phi φ\\varphiφ \\varphi chi XXX X χ\\chiχ \\chi psi Ψ\\PsiΨ \\Psi ψ\\psiψ \\psi omega Ω\\OmegaΩ \\Omega ω\\omegaω \\omega 括号 小括号与中括号可以直接使用 符号 Markdown原文 {\\lbrace{ \\lbrace }\\rbrace} \\rbrace ⟨\\langle⟨ \\langle ⟩\\rangle⟩ \\rangle ⌈\\lceil⌈ \\lceil ⌉\\rceil⌉ \\rceil ⌊\\lfloor⌊ \\lfloor ⌋\\rfloor⌋ \\rfloor MathJax公式编辑 行内公式：行内公式可以与其他内容显示在同一行 - 用法：用两个美元符$包裹住公式即可。 - $f(x)=ax+b$ 行间公式：行间公式会占据单独的行。 - 用法：公式前后各添加两个美元符 $$ f(x)=ax+b $$ 几个特殊符号 - **^表示上标** - `$a^2$` - $a^2$ - **\\_表示下标** - 由于markdown与MathJax的渲染有冲突，下划线必须使用反斜杠转义 - `$a\\_2$` - $a\\_2$ - **{}用于分组** - 举个例子，a的b乘c次方，需要对bc进行分组，否则就变成了a的b次方乘c。 - `$a^{bc}$` - $a^{bc}$ - **公式推倒过程** - 有时一行放不下所有的推导过程，放到多行并使得每行的等号对齐可以大大增加可读性。 - 下面这个例子原始形式是A，然后经过三步推导最终得到了D。 - 以符号 &amp; 的下一个字符进行对齐，末尾的三个反斜杠\\用来分割行。 $$ \\begin {aligned} A&amp;=B \\\\\\ &amp;=C\\\\\\ &amp;=D \\end {aligned} $$ 1234567$$\\begin &#123;aligned&#125;A&amp;&#x3D;B \\\\\\&amp;&#x3D;C\\\\\\&amp;&#x3D;D\\end &#123;aligned&#125;$$ 分段函数 - 以符号 &amp; 的下一个字符进行对齐，末尾的三个反斜杠\\用来分割行。 $$ sign(x)=\\begin {cases} +1, &amp; x\\geq0 \\\\\\ -1, &amp; x&lt;0 \\end {cases} $$ 123456$$sign(x)&#x3D;\\begin &#123;cases&#125;+1, &amp; x\\geq0 \\\\\\-1, &amp; x\\&lt;0\\end &#123;cases&#125;$$ 分数表示 - 用法：\\frac后面的两个分组分别作为分子和分母。 - $\\frac{1}{6}$ - `$\\frac{1}{6}$` MathJax用法及例子 输入开方 - \\sqrt{2} 和 \\sqrt{3} - $\\sqrt{2}$ 和 $\\sqrt{3}$ 输入省略号 - 数学公式中常见的省略号有两种，\\ldots表示与文本底线对齐的省略号，\\cdots表示与文本中线对齐的省略号。 - f(x1,x2,\\ldots,xn) = x1^2 + x2^2 + \\cdots + xn^2 - $f(x1,x2,\\ldots,xn) = x1^2 + x2^2 + \\cdots + xn^2$ 输入矢量 - \\vec{a} \\cdot \\vec{b}=0 - $\\vec{a} \\cdot \\vec{b}=0$ 输入积分 - \\int_0^1 x^2 {\\rm d}x - $\\int_0^1 x^2 {\\rm d}x$ 极限运算 - \\lim_{n \\rightarrow +\\infty} \\frac{1}{n(n+1)} - $\\lim_{n \\rightarrow +\\infty} \\frac{1}{n(n+1)}$ 累加、累乘运算 - \\sum{i=0}^n \\frac{1}{i^2} 和 \\prod{i=0}^n \\frac{1}{i^2} - $\\sum{i=0}^n \\frac{1}{i^2} 和 \\prod{i=0}^n \\frac{1}{i^2}$ 其他特殊字符 关系运算符： 符号 表达式 ±\\pm± \\pm ×\\times× \\times ÷\\div÷ \\div ∣\\mid∣ \\mid ∤\\nmid∤ \\nmid ⋅\\cdot⋅ \\cdot ∘\\circ∘ \\circ ∗\\ast∗ \\ast ⨀\\bigodot⨀ \\bigodot ⨂\\bigotimes⨂ \\bigotimes ⨁\\bigoplus⨁ \\bigoplus ≤\\leq≤ \\leq ≥\\geq≥ \\geq ≠\\neq​= \\neq ≈\\approx≈ \\approx ≡\\equiv≡ \\equiv ∑\\sum∑ \\sum ∏\\prod∏ \\prod coprodcoprodcoprod \\coprod 集合运算符： 符号 表达式 ∈\\in∈ \\in ∉\\notin∈/​ \\notin ⊂\\subset⊂ \\subset ⊆\\subseteq⊆ \\subseteq ⊇\\supseteq⊇ \\supseteq ⋂\\bigcap⋂ \\bigcap ⋃\\bigcup⋃ \\bigcup ⋁\\bigvee⋁ \\bigvee ⋀\\bigwedge⋀ \\bigwedge ⨄\\biguplus⨄ \\biguplus ⨆\\bigsqcup⨆ \\bigsqcup 对数运算符： 符号 表达式 log⁡\\loglog \\log lg⁡\\lglg \\lg ln⁡\\lnln \\ln 三角函数运算符： 符号 表达式 ⊥\\bot⊥ \\bot ∠\\angle∠ \\angle 30∘30^\\circ30∘ 30^\\circ sin⁡\\sinsin \\sin cos⁡\\coscos \\cos tan⁡\\tantan \\tan cot⁡\\cotcot \\cot sec⁡\\secsec \\sec csc⁡\\csccsc \\csc 微积分运算符： 符号 表达式 ′\\prime′ \\prime ∫\\int∫ \\int ∬\\iint∬ \\iint ∭\\iiint∭ \\iiint \\iiiint \\iiiint ∮\\oint∮ \\oint lim⁡\\limlim \\lim lim⁡\\limlim \\lim ∞\\infty∞ \\infty ∇\\nabla∇ \\nabla 逻辑运算符 符号 表达式 ∵\\because∵ \\because ∴\\therefore∴ \\therefore ∀\\forall∀ \\forall ∃\\exists∃ \\exists ≠\\not=​= \\not= ⊄\\not\\subset​⊂ \\not\\subset 戴帽符号 符号 表达式 y^\\hat{y}y^​ \\hat{y} yˇ\\check{y}yˇ​ \\check{y} y˘\\breve{y}y˘​ \\breve{y} 连线符号 符号 表达式 a+b+c+d‾\\overline{a+b+c+d}a+b+c+d​ \\overline{a+b+c+d} a+b+c+d‾\\underline{a+b+c+d}a+b+c+d​ \\underline{a+b+c+d} a+b+c⏟1.0+d⏞2.0\\overbrace{a+\\underbrace{b+c}{1.0}+d}^{2.0}a+b+c​1.0+d​2.0​ \\overbrace{a+\\underbrace{b+c}{1.0}+d}^{2.0} 箭头符号： 符号 表达式 ↑\\uparrow↑ \\uparrow ↓\\downarrow↓ \\downarrow ⇑\\Uparrow⇑ \\Uparrow ⇓\\Downarrow⇓ \\Downarrow →\\rightarrow→ \\rightarrow ←\\leftarrow← \\leftarrow ⇒\\Rightarrow⇒ \\Rightarrow ⇐\\Leftarrow⇐ \\Leftarrow ⟶\\longrightarrow⟶ \\longrightarrow ⟵\\longleftarrow⟵ \\longleftarrow ⟹\\Longrightarrow⟹ \\Longrightarrow ⟸\\Longleftarrow⟸ \\Longleftarrow 要输出字符 空格 # $ % &amp; _ { } ，用命令： \\空格 # $ % &amp; _ { } 要对公式的某一部分字符进行字体转换，可以用{\\rm 需转换的部分字符}命令，其中\\rm可以参照下表选择合适的字体。一般情况下，公式默认为意大利体。 符号 意义 \\rm 罗马体 \\it 意大利体 \\bf 黑体 \\cal 花体 \\sl 倾斜体 \\sf 等线体 \\mit 数学斜体 \\tt 打字机字体 \\sc 小体大写字母","tags":[{"name":"MathJax","slug":"MathJax","permalink":"http://tech.noexception.cn/tags/MathJax/"}]},{"title":"C++读书笔记——函数","date":"2016-10-08T07:03:22.000Z","path":"2016/10/08/C-读书笔记——函数/","text":"整理读书笔记系列。 C++中的函数传递大致的分为两类： 当函数参数为引用类型时，它对应的实参被引用传递，或者函数被传引用调用。和其他引用一样，引用形参也是它绑定的对象别名；也就是说，引用形参是它对应的实参的别名。 当实参的值被拷贝给形参时，形参和实参是两个相互独立的对象。我们说这样的实参被值传递，或者函数被传值调用。 1. 传值参数 当初始化一个非引用的变量时，初始值被拷贝给变量。此时，对变量的改动不会影响初始值； 指针形参 指针的行为和其他非引用类型一样。当执行指针拷贝操作时，拷贝的是指针的值。拷贝之后，两个指针是不同的指针。因为指针是我们可以访问它所指向的对象，所以通过指针可以修改它所值对象的值。 s","tags":[]},{"title":"js的学习笔记——终篇","date":"2016-09-25T08:26:41.000Z","path":"2016/09/25/js的学习笔记——预备篇/","text":"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;鉴于目前Javascript如此火爆，再加上近日微信宣布的“小程序”功能，可想以后的前端工程师是有多么的热门了 一、JS基础语法： 变量的声明： - 语法：``var myname;`` 变量赋值： - 我觉得这里没啥好说的了。几乎所有编程语言的赋值都差不多… 表达式： 算术表达式； 字符串表达式； 关系表达式（比较）； 逻辑表达式。 运算符： 赋值运算符： - ``=`` - 支持复合赋值运算符，包含但不限于``+=, -=, /=`` 2. 算术运算符： - `+, -, *, /, %, ++(自加), --(自减)` 3. 字符串运算符： - `+, +=` 4. 比较运算符： - `==, !=, ===(比较值及类型), !==(比较值及类型), &lt;, &lt;=, &gt;, &gt;=` 5. 逻辑运算符： - `&amp;&amp;(与运算), ||(或运算), !(取反)` 6. 逐位运算符： 7. 特殊运算符： 1. new 运算符，创建对象（实例） - 语法：``对象名称 = new 对象类型(参数)`` 2. this 运算符，表示当前对象 - 语法：``this.属性`` 3. 条件运算符： - 语法：``&lt;条件表达式&gt; ? 第一个值:第二个值`` - 说明：当条件表达式为真时，执行第一个值，否则执行第二个值，如果有学过其他静态语言的同学，就回很熟悉了^_^ 8. 运算符执行的优选顺序： - 算数&gt;比较＞逻辑＞赋值 二、数组 创建数组： - ``var myarray = new Array()`` 数组赋值： - `var myarray = new Array(66, 88, 99);` - `var myarray = [66, 88, 99];` 向数组增加一个新元素 - ```javascript myarray[5] = 22; //原数组长为4 12345678910 4. 二维数组： - 定义方法一：&#96;&#96;&#96;javascript var myarr &#x3D; new Array(); for(var i &#x3D; 0; i&lt;2; i++)&#123; myarr[i] &#x3D; new Array(); for(var j &#x3D; 0; j&lt;i; j++)&#123; myarr[i][j] &#x3D; i+j; &#125; &#125; - 定义方法二： 1var Myarr = [[0, 1, 2], [1, 2, 3]]; 三、事件响应 主要事件： 事件 说明 onclick 鼠标单机事件 onmouseover 鼠标经过事件 onmouseout 鼠标移开事件 onchange 文本框内容改变事件 onselect 文本框内容被选中事件 onfocus 光标聚焦 onblur 光标离开 onload 网页导入/加载事件 onunload 关闭网页/卸载事件 获取元素的值和获取方法： - 赋值：`document.getElementById(&quot;is&quot;).value=1;` - 取值：`var=document.getElementById(&quot;id&quot;).value;` - 使用 parseInt() 函数可以解析一个字符串，并返回一个整数。 四、JavaScript内置对象 对象： - JS中所有事物都是对象； - 每个对象都带有属性方法 Date 日期对象 - 语法：`var Udate = new Date();` - 注意：默认初始值为当前时间（当前电脑系统的时间）。 - 访问方法语法：&lt;日期对象&gt;.&lt;方法&gt; - Date对象中处理时间和日期的方法： 方法名称功能描述get/setDate()返回/设置日期get/setFullYear()返回/设置年份，用四位数表示get/setMonth()返回/设置月份，0表示一月；以此类推get/setHours()返回/设置小时，24小时制get/setMinutes()返回/设置分钟数get/setSeconds()返回/设置秒钟数get/setTime()返回/设置时间内（毫秒为单位） 返回/设置年份方法： - eg: 1234//获取：mydate.getFullYear();//设置：mydate.setFullYear(); 返回/设置星期方法： - eg: 123//方法：getDay();//返回的是0-6的数字，0表示星期天，若要返回对应的“星期”，可通过数组完成。 返回/设置时间方法： - **方法：**get/setTime(); - **注意：** 1. 一小时60分，一分60秒，一秒100毫秒； 2. 时间推迟1小时，就是``x.setTime(x.getTime()+60*60*100);`` String字符串对象（类JAVA） - 123x.length; //返回字符串的长度x.toUpperCase(); //转大写字母x.toLowerCase(); //转小写字母 返回指定位置的字符： - **语法：**``stringObject.charAt(index)`` - **参数说明：** - `index`：必需，表示字符串某个位置的数字，即字符在字符串中的下标。 返回指定字符串首次出现的位置 - **语法：**``stringObject.indexOf(substring,starpos)`` - **参数说明：** 1. ``substring``：必需，规定需检索的字符串值； 2. ``starpos``：可选的整数参数，规定在字符串开始检索的位置。它的合法取值是0到stringObject.length-1。如省略该z高数，则将字符串的首字符开始检索。 字符串分割split() - **语法:**``stringObject.split(separator,limit)`` - **参数说明：** 1. `Separator`：必需。从该参数指定的地方分割stringObject; 2. `limit`：可选参数；分割的次数，如设置该参数，返回的子串不会多于这个参数指定的数组，如果无此参数为不限制次数 提取字符串substring() - **功能：**用于提取字符串中介于两个指定下标之间的字符。 - **语法：**``stringObject.substring(starPos,stopPos)`` - **参数说明：** 1. `starPos`： 必需，一个非负的整数，开始的位置； 2. `stopPos`： 可选，一个非负的整数。结束的位置，如果省略此参数，那么返回的子串会一直到字符串对象的结尾。 - **注意：** 1. 返回的内容是从star开始（包含star位置的字符）到stop-1处的所有字符，其长度为stop减star 2. 如果参数star到stop相等，那么该方法返回的就是一个空串（即长度为0的字符串） 3. 如果star比stop大，那该方法在提取字符串之前会先交换这两个参数 提取指定数目的字符substr() - **功能：**从字符串中提取从starPos位置开始的指定数目的字符串 - **语法：**``stringObject.substr(starPos,length)`` - **参数说明：** 1. ``starPos``：必需，要提取的子串起始位置。必需是数值。 2. `length`：可选，提取字符串子串的长度，如果省略，返回从`stringObject`的开始位置starPos到stringObject的结尾的字符 - **注意：** - 如果参数starPos是负数，从字符串的尾部开始算起的位置，也就是说，-1指字符串最后一个字符，-2指倒数第二个字符，以此类推，如果starPos为负数且绝对值大于字符串长度，starPos为0. Math对象 Math对象，提供数据的数学计算 使用Math的属性和方法： eg: 123456 &lt;script type=\"text/javascript\"&gt; var mypi=Math.PI; var myabs=Math.abs(-15); document.write(mypi); document.write(myabs);&lt;/script&gt;","tags":[]},{"title":"js的学习笔记——预备篇","date":"2016-09-22T10:44:41.000Z","path":"2016/09/22/js的学习笔记/","text":"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;本篇文章会介绍之前学习Javascript时的一些笔记，苦于不知道可以写些啥有营养的东西。昨晚就忽然想到最近的Javascript这么火爆，于是乎就把以前学习的Javascript的笔记再整理一遍到自己这个“处女”博客吧~哈哈哈~ 一、预备知识： 1. 在HTML文本中嵌入Javascript的方式一共有三种： 内部引用 内联引用 外部引用 但是，我们用的最多的是外部引用这种方式，如下代码所示： 1&lt;script type=\"text/javascript\" src=\"path/to/your_code.js\"&gt;&lt;/script&gt; 上述代码可以放在html页面内的任何位置，具体要放在哪里，视具体情况而定了…… 2. 注释： 关于JS的注释方法，我一直是使用C++风格的注释方法，即：//这是一行注释，可能是用久了就成为习惯了吧，哈哈哈，不过另外值得注意的是，如果是使用“WebStorm”的话，尽量使用快捷键，我记得单行注释的快捷键是：Ctrl + /，要是用到多行注释的时候就可以输入/**然后键入回车即可。 3. 变量： 定义变量要使用关键字：var，语法：var 变量名 命名规则： 变量名必须使用字母、下划线或者美元符号开始； 可以使用任意多个英文字母、数字、下划线或美元符号； 不能使用JS关键字和JS保留字。 注意： - 变量要先声明，再赋值 - 变量可以重复赋值； - 在JS中区分大小写； - 变量可以不声明，直接使用，但是不推荐，不规范； 4. 语句 这里常用到的语句无非就是这几种： 赋值语句； 判断语句； 循环语句； 选择语句。 5. 函数 定义的方法： 1234567//*** 函数的参数可以有任意多个* 函数可以有返回值**/function fun1(arg1, arg2)&#123; //your code&#125; 函数的调用： 放在&lt;head&gt;标签之间，会自动运行 使用标签&lt;input type=&quot;button&quot; value=&quot;点击&quot; onclick=&quot;函数名&quot;&gt; 二、JS常用的互动方法 1. 内容输出（document.write） document.write可用于直接想HTML输出流写内容。 输出内容直接用“双引号”括起来，直接输出引号内的内容。 通过变量输出内容： eg: document.write(mystr); 输出多项内容，内容之间用&quot;+&quot;号连接 eg: document.write(mystr+&quot;Hello&quot;); 输出HTML标签 eg: document.write(mystr+&quot;&lt;br&gt;&quot;); 2. alert消息提示窗 alert(str) 3. 确认（confirm消息对话框） 作用：用于允许用户做选择的动作； 语法：confirm(str);； 参数说明： **str**在消息对话框中要显示的文本返回值Boolean值 4. 提问（prompt消息对话框） **作用：**通常用于询问一些需要用户交互的信息。弹出消息对话框（包含一个确定按钮，取消按钮与一个文本输入框） 语法：prompt(str1,str2); 参数说明： **str1**要显示在消息对话框的文本，不可修改；**str2**文本框中的内容，可修改 - **返回值：** 1. 点击确定按钮，文本款的内容将作为函数返回值； 2. 点击取消按钮，返回`null`; 5. 打开新窗口（window.open） 作用：open()方法可以查找一个已经存在或者新建的浏览器窗口； 语法：window.open([URL],[窗口名称],[参数字符串])；； 参数说明： URL:可选参数，在窗口中要显示网页的网址或路径。如果省略这个参数，或者它的值是空字符串，那么窗口就不显示任何文档； 窗口名称：可选参数,被打开窗口的名称。 该名称由字母、数字、下划线字符组成； _top,_blank,_self具有特殊意义的名称； _top：框架网页中在上不窗口中显示目标网页； _blank：在新窗口中显示目标网页； _self：在当前窗口显示目标网页。 相同name的窗口只能创建一个，要想创建多个窗口，则name不能相同。 name不能包含空格 参数字符串：可选参数，设置窗口参数，各参数用逗号隔开。 参数表： 参数值说明topnumber窗口顶部离开屏幕顶部的像素数leftnumber窗口左端离开屏幕左端的像素数widthnumber窗口的宽度heightnumber窗口的高度menubaryes,no窗口有没有菜单toolbaryes,no窗口有没有工具条scrollyes,no窗口有没有滚动条statusyes,no窗口有没有状态栏 6. 关闭窗口（window.close） **作用：**关闭窗口； 语法： 12window.close();//关闭当前窗口&lt;窗口对象&gt;.close();//关闭指定窗口 eg:关闭新建的窗口： 12var mywin = window.open('http://imooc.com');mywin.close(); 三、DOM操作 介绍： 文档对象模型（DOM）定义访问和处理HTML文档的标准方法。 HTML文档可以说有节点构成的集合。 1. 三种常见的DOM节点： 元素节点：&lt;html&gt;,&lt;body&gt;,&lt;p&gt;等，即标签； **文本节点：**向用户展示的内容，如&lt;li&gt;...&lt;/li&gt;中的JavaScript **属性节点：**元素属性，如&lt;a&gt;标签的链接属性。 2. 通过ID获取元素 语法：document.getElementById(&quot;id&quot;); 获取的元素是一个对象，如想对元素进行操作，我们要通过它的属性或方法。 3. innerHTML属性 语法：object.innerHTML; **作用：**innerHTML属性用于获取或替换HTML元素的内容 Object是获取的元素对象，如通过document.getElementById(&quot;ID&quot;);获取的元素； innerHTML区分大小写 eg： 1234var mycon = document.getElementById(\"con\");document.write(\"......\"+mycon.innerHTML+\"&lt;br&gt;\");mycon.innerHTML=\"New text!\";document.write(\"...\"+mycon.innerHTML+\"&lt;br&gt;\"); 4. 改变HTML样式： HTML DOM允许Javascript改变HTML元素的样式 语法：object.style.properly=new style; **注意：**Object是获取的元素对象，如通过getElementById(&quot;ID&quot;);获取的元素。 基本属性表(property)： 属性描述backgroundColor设置元素背景颜色height设置元素的高度width设置元素的宽度color设置文本的颜色font在一行设置所有字体的属性fontFamily设置元素的字体系列fontSize设置元素的字体大小 5. 显示和隐藏(display属性) 网页中经常会看到显示和隐藏的效果，可以通过display属性来设置 语法：Object.style.display=value; 注意： Object是获取的元素对象，如通过document.getElementById(&quot;id&quot;)获取的元素。 value的取值： 值描述none此元素不会被显示（即隐藏）block此元素显示为块级元素（即显示） 6. 控制类名（className属性） className属性设置或返回元素的class属性 语法：Object.className=classname; 作用： 获取元素的class属性； 为网页的某个元素指定一个CSS样式来更改元素的外观。","tags":[]},{"title":"okhttp边学边记","date":"2016-09-18T16:28:38.000Z","path":"2016/09/19/okhttp边学边记/","text":"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;学习安卓一定离不开网络访问，但是官方已经不推荐使用HttpClient了，我们需要一个好用的网络库，这时，就想到了okhttp。 一、导包 对于Android Studio的用户：compile 'com.squareup.okhttp3:okhttp:(insert latest version)'(目前的最新版本是3.4.1) 对于Eclipse的用户：可以直接下载[the lastest JAR],导入项目中即可。 注意：官方文档里说到，“当使用到快速I/O和resizable buffers的时候需要okio”所以，还有一步： 对于Android Studio的用户：compile 'com.squareup.okio:okio:(insert latest version)'(目前的最新版本是1.10.0) 对于Eclipse的用户：下载最近的 [ the lastest JAR ] 即可 二、使用步骤： HttpGet - 首先从最常用到的http get请求开始，例子： - ```java //创建okHttp对象 OkHttpClient client = new OkHttpClient(); //创建一个Request final Request request = new Request.Builder().url(&quot;http://luciferlv.tech&quot;).build(); //new call Call call = client.newCall(request); //请求加入调度 call.enqueue(new CallBack(){ @Override public void onFailure(Request request, IOException e){ } @Override public void onResponse(final Response response) throws IOException{ //String htmlStr = response.body().string(); } }) 123456789101112131415161718- 代码分析： 1. 发送一个get请求的步骤：首先构造一个Request对象，参数起码有一个url，也可以通过Request.Builder来设置更多的参数如：&#96;header和method&#96;等。 2. 然后通过request的对象去构造得到一个Call对象，类似于将你的请求封装成了任务，既然是任务，就会有&#96;execute()&#96;和&#96;cancel()&#96;等方法。 3. 最后，我们希望以**异步**的方式去执行请求，所以我们调用的是&#96;call.enqueue&#96;，将call加入调度队列，然后等待任务执行完成，我们在CallBack中即可得到结果。 - **注意：** - &#96;onResponse&#96;回调的参数是response，一般情况下，比如我们希望获得返回的字符串，可以通过&#96;response.body().string()&#96;获取；如果希望获得返回的二进制字节数组，则调用&#96;response.body().bytes();&#96;如果想拿到返回的inputStream，则调用&#96;response.body().byteStream();&#96;，我们能拿到&#96;inputStream&#96;就可以通过IO的方式下载大文件（写文件）。 - 还有一个问题&#96;onResponse&#96;执行的线程并不是UI线程。如果希望操作控件，还是需要用到handler等。如： - &#96;&#96;&#96;java @Override public void onResponse(final Response response) throws IOException&#123; final String res &#x3D; response.body().string(); runOnUiThread(new Runnable()&#123; @Override public void run()&#123; mTextView.setText(res); &#125; &#125;); &#125; - 我们这里是异步的方式去执行，当然也支持阻塞的方式，上面也说了Call有一个`execute()`方法，你也可以直接调用`call.execute()`通过返回一个`Response`。 HttpPost携带参数 - 当请求需要提交参数的时候，我们就会用到post请求，和Get不同的就是Request构造的不同 12345678910111213141516Request request = buildMultipartFormRequest(url, new File[]&#123;file&#125;, new String[]&#123;fileKey&#125;, null);FormEncodingBuilder builder = new FormEncodingBuilder();builder.add(\"username\", \"Lucifer\");Request request = new Request.Builder.url(url).post(builder.build()).build();client.newCall(request).enqueue(new CallBack()&#123; @Override public void onFailure(Request request, IOException e)&#123; &#125; @Override public void onResponse(final Response response) throws IOException&#123; // &#125;&#125;); - 大家都清除，post的矢耦，参数是包含在请求体中的；所以我们通过FormEncodingBuilder。添加多个String键值对，然后去构造RequestBody，最后完成我们Request的构造。后面的就和上面的是一样的了。 基于http的文件上传 - 接下来我们再介绍一个可以构造RequestBody的Builder，叫做`MultipartBuilder`。当我们需要做类似与表单上传的时候，就可以用它来构造我们的requestBody。 123456789101112131415161718192021222324252627File file = new File(Environment.getExternalStorageDirectory(), \"balabala.mp4\");RequestBody fileBody = RequestBody.create(MediaType.parse(\"application/octet-stream\"), file);RequestBody requestBody = new MultipartBuilder() .type(MultipartBuilder.FORM) .addPart(Headers.of(\"Content-Dispostion\", \"form-data; name=\\\"username\\\"\"), RequestBody.create(null, \"Lucifer\")) .addPart(Heafers.of(\"Content-Dispostion\", \"form-data; name=\\\"mFile\\\"; fileName=\\\"wjd.mp4\\\"\"), fileBody) .build();Request request = new Request.Builder() .url(\"http://192.168.1.103:8080/okHttpServer/fileUpload\") .post(requestBody) .build();Call call = client.newCall(request);call.enqueue(new CallBack()&#123; @Override public void onFailure(Request request, IOException e)&#123; &#125; @Override public void onResponse(final Response response) throws IOException&#123; // &#125;&#125;); - 上述代码向服务器传递了一个键值对`username: Lucifer`和一个文件。我们通过MultipartBuilder的addPart()方法可以添加键值对或者文件。 - 其实类似于我们拼接浏览器行为的方式 - **图片下载：**通过回调的Response拿到byte[]然后decode成图片； - **文件下载：**通过拿到inputStream做写文件操作。 三、封装 由于按照上述的代码，请求多了重复的代码就多了，我们就希望封装这些代码 使用： 一般的get请求 1234567891011OkHttpClientManager.getAsyn(\"https://www.baidu.com\", new OkHttpClientManager.ResultCallBack&lt;String&gt;()&#123; @Override public void onError(Request request, Exception e)&#123; e.printStackTrace(); &#125; @Override public void onResponse(String u)&#123; mTextView.setText(u);//这里是UI线程 &#125;&#125;); - 对于一把的请求，我们希望给个url，然后CallBack里面直接操作控件。 2. 文件上传且携带参数 - 我们希望提供一个方法，传入url, params, file, callback即可。 123456789101112131415161718OkHttpClientManager.postAsyn(\"http://192.168.1.103:8080/okHttpServer/fileUpload\", //参数1 new OkHttpClientManager.ResultCallBack&lt;String&gt;()&#123; @Override public void onError(Request request, IOException e)&#123; e.printStackTrace(); &#125; @Override public void onResponse(String result)&#123; &#125; &#125;,//参数2 file, //参数3 \"mFile\",//参数4 new OkHttpClientManager.Param[]&#123; new OkHttpClientManager.param(\"username\", \"lt\"), new OkHttpClientManager.param(\"password\", \"123\") &#125;); - 参数3为file，参数4为file对应的name，这个name不是文件的名字； - 对应于http中的`&lt;input type=&quot;file&quot; name=&quot;mFile&quot; &gt;` - 对应的是name后面的值，即mFile。 3. 文件下载 - 对于文件下载，提供url，目标dir，callback即可。 12345678910111213OkHttpClientManager.downloadAsyn(\"http://192.168.1.103:8080/okHttpServer/files/message_01.png\",// Environment.getExternalStorageDirectory().getAbsolutePath(),// new OkHttpClientManager.ResultCallBack&lt;String&gt;()&#123; @Override public void onError(Request request, IOException e)&#123; &#125; @Override public void onResponse(String response)&#123; //文件下载成功，这里回调的response为文件的absolutePath &#125; &#125;); 4. 展示图片 - 展示图片，我们希望提供一个url和一个imageView，如果下载成功，直接帮我们设置上即可。 1OkHttpClientManager.displayImage(mImageView, \"http://192.168.1.103:8080/20150817/1.jpg\"); - 内部会自动根据imageView的大小自动对图片进行合适的压缩。虽然，这里可能不适合一次性加载大量图片的场景，但是对于app中偶尔有几个图片的加载，还是可用的。 四、整合Gson 项目中使用时，服务端返回的是Json字符串，希望客户端回调可以直接拿到对象，于是整合进入Gson。 直接回调对象 - 例如现在有个User实体类： 123456789101112131415161718192021public class User&#123; public String username; public String password; public User()&#123; &#125; public User(String username, String password)&#123; this.username = username; this.password = password; &#125; @Override public String toString()&#123; return \"User&#123;\"+ \"username='\" + username + '\\'' + \",password='\" + password + '\\'' + \"&#125;\"; &#125;&#125; - 服务端返回：``{&quot;username&quot;:&quot;lt&quot;, &quot;password&quot;:&quot;123&quot;}`` - 客户端可以如下方式的调用： 123456789101112OkHttpClientManager.getAsyn(\"http://192.168.56.1:8080/okHttpServer/user!getUser\", new OkHttpClientManager.ResultCallBack&lt;User&gt;()&#123; @Override public void onError(Request request, Exception e)&#123; e.printStackTrace(); &#125; @Override public void onResponse(User user)&#123; mTextView.setText(user.toString());//UI线程 &#125; &#125;); - 我们传入泛型User，在onResponse里面直接回调User对象。 - **注意：**如果在`json字符串-&gt;实体对象`过程中发生错误，程序不会崩溃，`onError`方法会被回调。 回调对象集合 - 依然是上述的User类，服务端返回 - ``[{&quot;username&quot;:&quot;lt&quot;,&quot;password&quot;:&quot;123&quot;},{&quot;username&quot;:&quot;chl&quot;,&quot;password&quot;:&quot;12345&quot;}]`` - 则客户端可以如下调用： - ```java OkHttpClientManager.getAsyn(&quot;http://192.168.56.1:8080/okHttpServer/user!getUsers&quot;,// new OkHttpClientManager.ResultCallBack&lt;List&lt;User&gt;&gt;(){ @Override public void onError(Request request, Exception e){ e.printStackTrace(); } @Override public void onResponse(List&lt;User&gt; us){ Log.e(&quot;TAG&quot;, us.size() + &quot; &quot;); mTextView.setText(us.get(1).toString()); } }); 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645646647648649650651652653654655 - 唯一的区别，就是泛型变成了&#96;List&lt;User&gt;&#96;。### OkHttpClientManager的源码&#96;&#96;&#96;javapublic class OkHttpClientManager&#123; private static OkHttpClientManager mInstance; private OkHttpClient mOkHttpClient; private Handler mDelivery; private Gson mGson; private static final String TAG &#x3D; &quot;OkHttpClientManager&quot;; private OkHttpClientManager() &#123; mOkHttpClient &#x3D; new OkHttpClient(); &#x2F;&#x2F;cookie enabled mOkHttpClient.setCookieHandler(new CookieManager(null, CookiePolicy.ACCEPT_ORIGINAL_SERVER)); mDelivery &#x3D; new Handler(Looper.getMainLooper()); mGson &#x3D; new Gson(); &#125; public static OkHttpClientManager getInstance() &#123; if (mInstance &#x3D;&#x3D; null) &#123; synchronized (OkHttpClientManager.class) &#123; if (mInstance &#x3D;&#x3D; null) &#123; mInstance &#x3D; new OkHttpClientManager(); &#125; &#125; &#125; return mInstance; &#125; &#x2F;** * 同步的Get请求 * * @param url * @return Response *&#x2F; private Response _getAsyn(String url) throws IOException &#123; final Request request &#x3D; new Request.Builder() .url(url) .build(); Call call &#x3D; mOkHttpClient.newCall(request); Response execute &#x3D; call.execute(); return execute; &#125; &#x2F;** * 同步的Get请求 * * @param url * @return 字符串 *&#x2F; private String _getAsString(String url) throws IOException &#123; Response execute &#x3D; _getAsyn(url); return execute.body().string(); &#125; &#x2F;** * 异步的get请求 * * @param url * @param callback *&#x2F; private void _getAsyn(String url, final ResultCallback callback) &#123; final Request request &#x3D; new Request.Builder() .url(url) .build(); deliveryResult(callback, request); &#125; &#x2F;** * 同步的Post请求 * * @param url * @param params post的参数 * @return *&#x2F; private Response _post(String url, Param... params) throws IOException &#123; Request request &#x3D; buildPostRequest(url, params); Response response &#x3D; mOkHttpClient.newCall(request).execute(); return response; &#125; &#x2F;** * 同步的Post请求 * * @param url * @param params post的参数 * @return 字符串 *&#x2F; private String _postAsString(String url, Param... params) throws IOException &#123; Response response &#x3D; _post(url, params); return response.body().string(); &#125; &#x2F;** * 异步的post请求 * * @param url * @param callback * @param params *&#x2F; private void _postAsyn(String url, final ResultCallback callback, Param... params) &#123; Request request &#x3D; buildPostRequest(url, params); deliveryResult(callback, request); &#125; &#x2F;** * 异步的post请求 * * @param url * @param callback * @param params *&#x2F; private void _postAsyn(String url, final ResultCallback callback, Map&lt;String, String&gt; params) &#123; Param[] paramsArr &#x3D; map2Params(params); Request request &#x3D; buildPostRequest(url, paramsArr); deliveryResult(callback, request); &#125; &#x2F;** * 同步基于post的文件上传 * * @param params * @return *&#x2F; private Response _post(String url, File[] files, String[] fileKeys, Param... params) throws IOException &#123; Request request &#x3D; buildMultipartFormRequest(url, files, fileKeys, params); return mOkHttpClient.newCall(request).execute(); &#125; private Response _post(String url, File file, String fileKey) throws IOException &#123; Request request &#x3D; buildMultipartFormRequest(url, new File[]&#123;file&#125;, new String[]&#123;fileKey&#125;, null); return mOkHttpClient.newCall(request).execute(); &#125; private Response _post(String url, File file, String fileKey, Param... params) throws IOException &#123; Request request &#x3D; buildMultipartFormRequest(url, new File[]&#123;file&#125;, new String[]&#123;fileKey&#125;, params); return mOkHttpClient.newCall(request).execute(); &#125; &#x2F;** * 异步基于post的文件上传 * * @param url * @param callback * @param files * @param fileKeys * @throws IOException *&#x2F; private void _postAsyn(String url, ResultCallback callback, File[] files, String[] fileKeys, Param... params) throws IOException &#123; Request request &#x3D; buildMultipartFormRequest(url, files, fileKeys, params); deliveryResult(callback, request); &#125; &#x2F;** * 异步基于post的文件上传，单文件不带参数上传 * * @param url * @param callback * @param file * @param fileKey * @throws IOException *&#x2F; private void _postAsyn(String url, ResultCallback callback, File file, String fileKey) throws IOException &#123; Request request &#x3D; buildMultipartFormRequest(url, new File[]&#123;file&#125;, new String[]&#123;fileKey&#125;, null); deliveryResult(callback, request); &#125; &#x2F;** * 异步基于post的文件上传，单文件且携带其他form参数上传 * * @param url * @param callback * @param file * @param fileKey * @param params * @throws IOException *&#x2F; private void _postAsyn(String url, ResultCallback callback, File file, String fileKey, Param... params) throws IOException &#123; Request request &#x3D; buildMultipartFormRequest(url, new File[]&#123;file&#125;, new String[]&#123;fileKey&#125;, params); deliveryResult(callback, request); &#125; &#x2F;** * 异步下载文件 * * @param url * @param destFileDir 本地文件存储的文件夹 * @param callback *&#x2F; private void _downloadAsyn(final String url, final String destFileDir, final ResultCallback callback) &#123; final Request request &#x3D; new Request.Builder() .url(url) .build(); final Call call &#x3D; mOkHttpClient.newCall(request); call.enqueue(new Callback() &#123; @Override public void onFailure(final Request request, final IOException e) &#123; sendFailedStringCallback(request, e, callback); &#125; @Override public void onResponse(Response response) &#123; InputStream is &#x3D; null; byte[] buf &#x3D; new byte[2048]; int len &#x3D; 0; FileOutputStream fos &#x3D; null; try &#123; is &#x3D; response.body().byteStream(); File file &#x3D; new File(destFileDir, getFileName(url)); fos &#x3D; new FileOutputStream(file); while ((len &#x3D; is.read(buf)) !&#x3D; -1) &#123; fos.write(buf, 0, len); &#125; fos.flush(); &#x2F;&#x2F;如果下载文件成功，第一个参数为文件的绝对路径 sendSuccessResultCallback(file.getAbsolutePath(), callback); &#125; catch (IOException e) &#123; sendFailedStringCallback(response.request(), e, callback); &#125; finally &#123; try &#123; if (is !&#x3D; null) is.close(); &#125; catch (IOException e) &#123; &#125; try &#123; if (fos !&#x3D; null) fos.close(); &#125; catch (IOException e) &#123; &#125; &#125; &#125; &#125;); &#125; private String getFileName(String path) &#123; int separatorIndex &#x3D; path.lastIndexOf(&quot;&#x2F;&quot;); return (separatorIndex &lt; 0) ? path : path.substring(separatorIndex + 1, path.length()); &#125; &#x2F;** * 加载图片 * * @param view * @param url * @throws IOException *&#x2F; private void _displayImage(final ImageView view, final String url, final int errorResId) &#123; final Request request &#x3D; new Request.Builder() .url(url) .build(); Call call &#x3D; mOkHttpClient.newCall(request); call.enqueue(new Callback() &#123; @Override public void onFailure(Request request, IOException e) &#123; setErrorResId(view, errorResId); &#125; @Override public void onResponse(Response response) &#123; InputStream is &#x3D; null; try &#123; is &#x3D; response.body().byteStream(); ImageUtils.ImageSize actualImageSize &#x3D; ImageUtils.getImageSize(is); ImageUtils.ImageSize imageViewSize &#x3D; ImageUtils.getImageViewSize(view); int inSampleSize &#x3D; ImageUtils.calculateInSampleSize(actualImageSize, imageViewSize); try &#123; is.reset(); &#125; catch (IOException e) &#123; response &#x3D; _getAsyn(url); is &#x3D; response.body().byteStream(); &#125; BitmapFactory.Options ops &#x3D; new BitmapFactory.Options(); ops.inJustDecodeBounds &#x3D; false; ops.inSampleSize &#x3D; inSampleSize; final Bitmap bm &#x3D; BitmapFactory.decodeStream(is, null, ops); mDelivery.post(new Runnable() &#123; @Override public void run() &#123; view.setImageBitmap(bm); &#125; &#125;); &#125; catch (Exception e) &#123; setErrorResId(view, errorResId); &#125; finally &#123; if (is !&#x3D; null) try &#123; is.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125;); &#125; private void setErrorResId(final ImageView view, final int errorResId) &#123; mDelivery.post(new Runnable() &#123; @Override public void run() &#123; view.setImageResource(errorResId); &#125; &#125;); &#125; &#x2F;&#x2F;*************对外公布的方法************ public static Response getAsyn(String url) throws IOException &#123; return getInstance()._getAsyn(url); &#125; public static String getAsString(String url) throws IOException &#123; return getInstance()._getAsString(url); &#125; public static void getAsyn(String url, ResultCallback callback) &#123; getInstance()._getAsyn(url, callback); &#125; public static Response post(String url, Param... params) throws IOException &#123; return getInstance()._post(url, params); &#125; public static String postAsString(String url, Param... params) throws IOException &#123; return getInstance()._postAsString(url, params); &#125; public static void postAsyn(String url, final ResultCallback callback, Param... params) &#123; getInstance()._postAsyn(url, callback, params); &#125; public static void postAsyn(String url, final ResultCallback callback, Map&lt;String, String&gt; params) &#123; getInstance()._postAsyn(url, callback, params); &#125; public static Response post(String url, File[] files, String[] fileKeys, Param... params) throws IOException &#123; return getInstance()._post(url, files, fileKeys, params); &#125; public static Response post(String url, File file, String fileKey) throws IOException &#123; return getInstance()._post(url, file, fileKey); &#125; public static Response post(String url, File file, String fileKey, Param... params) throws IOException &#123; return getInstance()._post(url, file, fileKey, params); &#125; public static void postAsyn(String url, ResultCallback callback, File[] files, String[] fileKeys, Param... params) throws IOException &#123; getInstance()._postAsyn(url, callback, files, fileKeys, params); &#125; public static void postAsyn(String url, ResultCallback callback, File file, String fileKey) throws IOException &#123; getInstance()._postAsyn(url, callback, file, fileKey); &#125; public static void postAsyn(String url, ResultCallback callback, File file, String fileKey, Param... params) throws IOException &#123; getInstance()._postAsyn(url, callback, file, fileKey, params); &#125; public static void displayImage(final ImageView view, String url, int errorResId) throws IOException &#123; getInstance()._displayImage(view, url, errorResId); &#125; public static void displayImage(final ImageView view, String url) &#123; getInstance()._displayImage(view, url, -1); &#125; public static void downloadAsyn(String url, String destDir, ResultCallback callback) &#123; getInstance()._downloadAsyn(url, destDir, callback); &#125; &#x2F;&#x2F;**************************** private Request buildMultipartFormRequest(String url, File[] files, String[] fileKeys, Param[] params) &#123; params &#x3D; validateParam(params); MultipartBuilder builder &#x3D; new MultipartBuilder() .type(MultipartBuilder.FORM); for (Param param : params) &#123; builder.addPart(Headers.of(&quot;Content-Disposition&quot;, &quot;form-data; name&#x3D;\\&quot;&quot; + param.key + &quot;\\&quot;&quot;), RequestBody.create(null, param.value)); &#125; if (files !&#x3D; null) &#123; RequestBody fileBody &#x3D; null; for (int i &#x3D; 0; i &lt; files.length; i++) &#123; File file &#x3D; files[i]; String fileName &#x3D; file.getName(); fileBody &#x3D; RequestBody.create(MediaType.parse(guessMimeType(fileName)), file); &#x2F;&#x2F;TODO 根据文件名设置contentType builder.addPart(Headers.of(&quot;Content-Disposition&quot;, &quot;form-data; name&#x3D;\\&quot;&quot; + fileKeys[i] + &quot;\\&quot;; filename&#x3D;\\&quot;&quot; + fileName + &quot;\\&quot;&quot;), fileBody); &#125; &#125; RequestBody requestBody &#x3D; builder.build(); return new Request.Builder() .url(url) .post(requestBody) .build(); &#125; private String guessMimeType(String path) &#123; FileNameMap fileNameMap &#x3D; URLConnection.getFileNameMap(); String contentTypeFor &#x3D; fileNameMap.getContentTypeFor(path); if (contentTypeFor &#x3D;&#x3D; null) &#123; contentTypeFor &#x3D; &quot;application&#x2F;octet-stream&quot;; &#125; return contentTypeFor; &#125; private Param[] validateParam(Param[] params) &#123; if (params &#x3D;&#x3D; null) return new Param[0]; else return params; &#125; private Param[] map2Params(Map&lt;String, String&gt; params) &#123; if (params &#x3D;&#x3D; null) return new Param[0]; int size &#x3D; params.size(); Param[] res &#x3D; new Param[size]; Set&lt;Map.Entry&lt;String, String&gt;&gt; entries &#x3D; params.entrySet(); int i &#x3D; 0; for (Map.Entry&lt;String, String&gt; entry : entries) &#123; res[i++] &#x3D; new Param(entry.getKey(), entry.getValue()); &#125; return res; &#125; private static final String SESSION_KEY &#x3D; &quot;Set-Cookie&quot;; private static final String mSessionKey &#x3D; &quot;JSESSIONID&quot;; private Map&lt;String, String&gt; mSessions &#x3D; new HashMap&lt;String, String&gt;(); private void deliveryResult(final ResultCallback callback, Request request) &#123; mOkHttpClient.newCall(request).enqueue(new Callback() &#123; @Override public void onFailure(final Request request, final IOException e) &#123; sendFailedStringCallback(request, e, callback); &#125; @Override public void onResponse(final Response response) &#123; try &#123; final String string &#x3D; response.body().string(); if (callback.mType &#x3D;&#x3D; String.class) &#123; sendSuccessResultCallback(string, callback); &#125; else &#123; Object o &#x3D; mGson.fromJson(string, callback.mType); sendSuccessResultCallback(o, callback); &#125; &#125; catch (IOException e) &#123; sendFailedStringCallback(response.request(), e, callback); &#125; catch (com.google.gson.JsonParseException e)&#x2F;&#x2F;Json解析的错误 &#123; sendFailedStringCallback(response.request(), e, callback); &#125; &#125; &#125;); &#125; private void sendFailedStringCallback(final Request request, final Exception e, final ResultCallback callback) &#123; mDelivery.post(new Runnable() &#123; @Override public void run() &#123; if (callback !&#x3D; null) callback.onError(request, e); &#125; &#125;); &#125; private void sendSuccessResultCallback(final Object object, final ResultCallback callback) &#123; mDelivery.post(new Runnable() &#123; @Override public void run() &#123; if (callback !&#x3D; null) &#123; callback.onResponse(object); &#125; &#125; &#125;); &#125; private Request buildPostRequest(String url, Param[] params) &#123; if (params &#x3D;&#x3D; null) &#123; params &#x3D; new Param[0]; &#125; FormEncodingBuilder builder &#x3D; new FormEncodingBuilder(); for (Param param : params) &#123; builder.add(param.key, param.value); &#125; RequestBody requestBody &#x3D; builder.build(); return new Request.Builder() .url(url) .post(requestBody) .build(); &#125; public static abstract class ResultCallback&lt;T&gt; &#123; Type mType; public ResultCallback() &#123; mType &#x3D; getSuperclassTypeParameter(getClass()); &#125; static Type getSuperclassTypeParameter(Class&lt;?&gt; subclass) &#123; Type superclass &#x3D; subclass.getGenericSuperclass(); if (superclass instanceof Class) &#123; throw new RuntimeException(&quot;Missing type parameter.&quot;); &#125; ParameterizedType parameterized &#x3D; (ParameterizedType) superclass; return $Gson$Types.canonicalize(parameterized.getActualTypeArguments()[0]); &#125; public abstract void onError(Request request, Exception e); public abstract void onResponse(T response); &#125; public static class Param &#123; public Param() &#123; &#125; public Param(String key, String value) &#123; this.key &#x3D; key; this.value &#x3D; value; &#125; String key; String value; &#125;&#125; 参考文献： [okhttp官方文档] [ 张鸿洋的博客——从原理角度解析Android （Java） http 文件上传 ] [Android OkHttp完全解析] [OkHttp官方API文档] https://github.com/square/okhttp/ https://github.com/hongyangAndroid/okhttp-utils","tags":[]},{"title":"Java中的正则表达式","date":"2016-09-17T03:31:23.000Z","path":"2016/09/17/Java中的正则表达式/","text":"很久以前，正则表达式就已经整合到标准Unix工具集之中，例如sed和awk，以及程序设计语言之中了，例如Python和Perl。而在JAVA中，字符串操作还主要集中于String、StringBuffer和StringTokenizer类。与正则表达式相比较，他们只能提供相当简单的功能。 基础 一般来说，正则表达式就是以某种方式描述字符串，因此你可以说：“如果一个字符串含有这些东西，那么它就是我正在找的东西。”例如，要找一个数字，它可能有一个负号在最前面，那你就写一个负号加上一个问号，就像这样：-? 要描述一个整数，你可以说它有一位或多位阿拉伯数字。在正则表达式中，用\\d表示一位数字。如果在其他语言中使用过正则表达式，那你立刻就能发现Java对反斜杠\\的不同处理。在其他语言中，\\\\表示“我想要在正则表达式中插入一个普通的（字面上的）反斜线，请不要给它任何特殊意义。”而在Java中，\\\\的意思是“我要插入一个正则表达式的反斜线，所以其后的字符具有特殊的意义。”例如，如果你想表示一个数字，那么正则表达式应该是\\\\d。如果你想插入一个普通的反斜线，则应该这样\\\\\\\\。不过换行和制表符之类的东西只需要使用单反斜线：\\n\\t。 要表示“一个或多个之前的表达式”，应该使用+。所以，如果要表示“可能有一个负号后面跟着一位或多位数字”，可以这样：-?\\\\d+ String类还自带了一个非常有用的正则表达式工具——split()方法，其功能是“将字符串从正则表达式匹配的地方切开。” 创建正则表达式 我们首先从正则表达式可能存在的构造集中选取一个很有用的子集，以此开始学习正则表达式。正则表达式的完整构造子列表，请参考JDK文档java.util.regex包中的Pattern类。 [Pattern] 量词 量词描述一个模式吸收输入文本的方式： 贪婪型：量词总是贪婪的，除非有其他的选项被设置。贪婪表达式会为所有可能的模式发现尽可能多的匹配。导致此问题的一个典型理由就是假定我们的模式仅能匹配第一个可能的字符组，如果它是贪婪的，那么它就会继续往下匹配。 勉强型：用问号来指定，这个量词匹配满足模式所需的最少字符数。因此也称作懒惰的、最少占匹配的、非贪婪的或不贪婪的。 占有型：目前，这种类型的量词只有在Java语言中才可用（其他语言中不可用），并且也更高级，因此我们大概不会立刻用到它。当正则表达式被应用于字符串时，它会产生相当多的状态，以便在匹配失败时可以回溯。而“占有的”量词并不保存这些中间状态，因此它们可以防止回溯。它们常常用于防止正则表达式时空，因此可以使正则表达式执行起来更有效。 Pattern和Matcher split() 替换操作 reset() 正则表达式与Java I/O 参考文献: 《Think in Java(4 Edtion)》","tags":[{"name":"正则表达式","slug":"正则表达式","permalink":"http://tech.noexception.cn/tags/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"}]},{"title":"关于英语学习","date":"2016-09-11T18:29:54.000Z","path":"2016/09/12/关于英语学习/","text":"[ 漏屋_天涯社区 ]","tags":[]},{"title":"关于指针的那点事","date":"2016-09-10T06:43:09.000Z","path":"2016/09/10/关于指针的那点事/","text":"一篇有助于理解C指针的文章 左值和右值 C++的表达式要不然是右值(rvalue，读作&quot;are-value&quot;)，要不然就是左值(lvalue，读作&quot;ell-valule&quot;)。这两个名次是从C语言继承过来的，原本就是为了帮助记忆的：左值可以位于赋值语句的左侧，右值不能。 在C++语言中，二者的区别就没有那么简单了。一个左值表达式的求值结果是一个对象或者一个函数，然而以常量对象为代表的某些左值实际上不能作为赋值语句的左侧运算对象。此外，虽然某些表达式的求值结果是对象，但它们是右值而非左值。可以做一个简单的归纳：当一个对象被用作右值的时候，用的是对象的值（内容）；当对象被用作左值的时候，用的是对象的身份（在内存中的位置）。 不同的运算符对运算对象的要求各有不同，有的需要左值运算对象、有的需要右值运算对象；返回值也有差异，有的得到左值结果、有的得到右值的结果。一个重要的原则是在需要右值的地方可以用左值来代替，但是不能把右值当成左值（也就是位置）使用。当一个左值被当成右值使用时，实际使用的是它的内容（值）。常见地，运算符要用到左值的有一下几个： 赋值运算符（*）需要一个（非常量）左值作为其左侧运算符对象，得到的结果也仍然是一个左值； 取地址符(&amp;)作用于一个左值元算对象，返回一个指向该运算对象的指针，这个指针是一个右值。 内置解析引用运算符、下标运算符、迭代器解析引用运算符、string和vector的下标运算符的求值结果都是左值。 内置类型和迭代器的递增递减运算符作用于左值运算对象，其前置版本所得的结果也是左值。","tags":[{"name":"指针","slug":"指针","permalink":"http://tech.noexception.cn/tags/%E6%8C%87%E9%92%88/"},{"name":"左值、右值","slug":"左值、右值","permalink":"http://tech.noexception.cn/tags/%E5%B7%A6%E5%80%BC%E3%80%81%E5%8F%B3%E5%80%BC/"}]},{"title":"关于Android程序崩溃的一些记录","date":"2016-08-22T14:54:55.000Z","path":"2016/08/22/关于Android程序崩溃的一些记录/","text":"Android应用崩溃的原因归纳 Android平台程序崩溃的类型及原因列举 Android平台程序崩溃大家都应该遇到过，force close和ANR应该是大家遇到较多的。 这里把Android平台程序崩溃的各种类型做一个简述和原因列举。 ANR（可见ANR）： 发生场景：应用发生ANR。 崩溃症状：系统弹出窗口询问用户选择“Force Close”或者“Wait”。 “Force Close”将杀掉发生ANR的应用进程。 “Wait”将会等待系统择机恢复此应用进程。 发生原因：（1）应用主线程卡住，对其他请求响应超时。（2）死锁。（3）系统反应迟钝。（4）CPU负载过重。 Force Close： 发生场景：应用进程崩溃。 崩溃症状：系统弹出窗口提示用户某进程崩溃。 发生原因：空指向异常或者未捕捉的异常。 Tombstones： 发生场景：Native层崩溃 崩溃症状：如果发生崩溃的native层和UI有关联（比如Browser），我们可以在UI上发现这个崩溃。 如果发生崩溃的native层是在后台并且和UI没有直接联系，那么对于用户来说是不可见的，如果是debug版本可能会有Log打印出当时的底层现场。 发生原因：各种各样，需要具体情况具体分析。 系统服务崩溃（System Server Crash）： 发生场景：系统服务是Android核心进程，此服务进程发生崩溃。 崩溃症状：手机重启到Android启动界面 发生原因：（1）系统服务看门狗发现异常。（2）系统服务发生未捕获异常。（3）OOM。（4）系统服务Native发生Tombstone。 Kernel Panics： 发生场景：Linux内核发生严重错误 崩溃症状：手机从bootloader开始完全重启 发生原因：（1）Linux内核内存空间发生内存崩溃。（2）内核看门狗发现异常。（3）空指针操作内核。 转自：http://www.cnblogs.com/mobile-veterans","tags":[{"name":"reports","slug":"reports","permalink":"http://tech.noexception.cn/tags/reports/"},{"name":"activity","slug":"activity","permalink":"http://tech.noexception.cn/tags/activity/"}]},{"title":"SuperRecyclerView用法","date":"2016-08-22T14:53:30.000Z","path":"2016/08/22/SuperRecyclerView用法/","text":"关于SuperRecyclerView的用法 1. 简介： SuperRecyclerView是支持addHeaderView、addFooterView、下拉刷新、分页加载数据的RecyclerView。 它对RecyclerView控件进行了拓展，给RecyclerView增加HeaderView、FooterView，并且不需要对你的Adapter做任何修改。 2. 主要功能 下拉刷新、滑动到底部自动加载下页数据； 可以方便添加Header和Footer； 头部下拉样式可以自定义； 具备item点击和长按事件。 网络错误加载加载失败点击Footer重新请求数据； 可以动态为FooterView赋予不同状态（加载中、加载失败、滑到最底等）。 3. 使用 添加HeaderView、FooterView 123456789101112mDataAdapter = new DataAdapter(this);mDataAdapter.setData(dataList);mHeaderAndFooterRecyclerViewAdapter = new HeaderAndFooterRecyclerViewAdapter(this, mDataAdapter);mRecyclerView.setAdapter(mHeaderAndFooterRecyclerViewAdapter);mRecyclerView.setLayoutManager(new LinearLayoutManager(this));//add a HeaderViewRecyclerViewUtils.setHeaderView(mRecyclerView, new SampleHeader(this));//add a FooterViewRecyclerViewUtils.setFooterView(mRecyclerView, new SampleFooter(this)); 添加滚动监听事件 1234567891011121314151617181920212223mRecyclerView.addOnScrolListener(mOnScrollListener);RecyclerOnScrollListener mOnScrollListener = new RecyclerOnScrollListener()&#123; @Override public void onBottom()&#123; LoadingFooter.State state = RecyclerViewUtils.getFooterViewState(mRecyclerView); if(state == LoadingFooter.State.Loading)&#123; Log.d(TAG, \"the state is Loading, just wait...\"); return; &#125; if(mCurrentCounter &lt; TOTAL_COUNTER)&#123; //loading more RecyclerViewStateUtils.setFooterViewState(EndlessLinearLayoutActivity.this, mRecyclerView, REQUEST_COUNT, LoadingFooter.State.Loading, null); requestData(); &#125;else&#123; //the end RecyclerViewStateUtils.setFooterViewState(EndlessLinearLayoutActivity.this, mRecyclerView, REQUEST_COUNT, LoadingFooter.State.TheEnd, null); &#125; &#125;&#125;; **RecyclerOnScrollListener**实现了**onScrollUp()、onScrollDown()、onBottom()、onScrolled()**四个事件，如下所示： 12345678//scroll down to uppublic abstrsct void onScrollUp();//scroll from up to downpublic abstrsct void onScrollDown();//load next pagepublid abstrsct void onBottom();//moving state,you can get the move distancepublic abstrsct void onScrolled(int distanceX, int distenceY); - **onScrollUp()**——RecyclerView向上滑动的监听事件； - **onScrollDown()**——RecyclerView向下滑动的监听事件； - **onBottom()**——RecyclerView滑动到底部的监听事件； - **onBottom()**——RecyclerView正在滚动的监听事件； 加载更多（加载下页数据） - 从上面的RecyclerOnScrollListener类的介绍中就可以看出，实现加载更多只要在**onBottom()**接口中处理即可。 未完待续……","tags":[{"name":"view","slug":"view","permalink":"http://tech.noexception.cn/tags/view/"}]},{"title":"CSS知识点整理","date":"2016-08-22T14:48:39.000Z","path":"2016/08/22/CSS知识点整理/","text":"CSS归纳 1. 对WEB标准以及W3C的理解与认知 标签闭合、标签小写、不乱嵌套、提高搜索机器人搜索几率； 使用外链CSS和JS脚本、结构行为表现的分离、文件下载与页面速度更快； 内容能被更多的用户所访问、内容能被更广泛的设备所访问、更少的代码和组件； 容易维护、改版方便，不需要变动页面内容； 提供打印版本而不需要复制内容、提高网站易用性； 2. xhtml和html有什么区别 HTML是一种基本的WEB网页设计语言，XHTML是一个基于XML的标志语言； 最主要的不同： XHTML元素必须被正确的嵌套。 XHTML元素必须被关闭。 XHTML标签名必须用小写字母。 XHTML文档必须拥有根元素。 3. Doctype?严格模式与混杂模式-如何触发这两种模式，区分它们有何意义？ 用于声明文档使用那种规范(html\\Xhtml)一般为：严格、过度、基于框架的html文档； 加入XML声明可触发，解析方式更改为IE5.5拥有IE5.5的bug； 4. 行内元素有哪些？块级元素有哪些？CSS的盒模型？ 块级元素：div p h1 h2 h3 h4 form ul 行内元素: a b br i span input select CSS盒模型：内容, border, margin, padding 5. CSS引入的方式有哪些？link和@import的区别是？ **引入方式：**内联、内嵌、外链、导入 link和@import区别： 同时加载； 前者无兼容，后者CSS2.1以下浏览器不支持； Link支持使用javascript改变样式，后者不可； 6. CSS选择符有哪些？哪些属性可以继承？优先级算法如何计算？内联和important哪个优先级高？ 选择符：标签选择符、类选择符、id选择符； 继承不如指定id&gt;class&gt;标签选择 内联和important优先级哪个高：important优先级高 7. 前端页面有哪三层构成，分别是什么？作用是什么？ **结构层：**Html **表示层：**CSS **行为层：**js 8. CSS的基本语句构成是？ 选择器{属性1:值1;属性2:值2;…} 9. 你做的页面在那些浏览器测试过？这些浏览器的内核分别是什么？ IE(IE内核)、火狐(Gecko)、谷歌(webkit)、opear(Presto) 10. 写出几种IE6 BUG的解决办法 双边距BUG：float引起的，使用display； 像素问题：使用float引起的，使用display:inline -3px; 超链接hover点击后失效：使用正确的书写顺序linkvisited hover activen IE z-index问题:给父级添加position:relative png透明：使用js代码改 min-height最小高度：important解决 select在IE6下遮盖：使用iframe嵌套； 为什么没有办法定义1px左右的宽度容器(IE6默认的行高造成的，使用over:hidden,0.08line-height:1px) 11. 标签title与alt属性的区别是什么？ Alt：当图片不显示是用文字代表。 Title：为该属性提供信息 12. 描述css reset的作用和用途。 css reset的作用：reset重置浏览器的css默认属性； 用途：浏览器的品种不同，样式不同，然后重置，让他们统一； 13. 解释css sprites，如何使用。 css sprites：把一堆小的图片整合到一张大的图片上，减轻服务器对图片的请求数量 14. 浏览器标准模式和怪异模式之间的区别是什么？ 盒子模型 渲染模式的不同 使用window.top.document.compatMode 可显示为什么模型 15. 你如何对网站的文件和资源进行优化？期待的解决方案包括： 文件合并 文件最小化/文件压缩 使用CDN托管 缓存的使用 16. 什么是语义化的HTML? 直观的认识标签，对于搜索引擎的抓取有好处 17. 清除浮动的几种方式，各自的优缺点 使用空标签清除浮动clear:both(理论上能清除任何标签，，，增加无意义的标签) 使用overflow:auto(空标签元素清除浮动而不得不增加无意代码的弊端，使用zoom:1用于兼容IE) 使用afert伪元素清除浮动（用于非IE浏览器）","tags":[{"name":"reports","slug":"reports","permalink":"http://tech.noexception.cn/tags/reports/"},{"name":"css","slug":"css","permalink":"http://tech.noexception.cn/tags/css/"}]},{"title":"用SSH实现无密码自动登陆","date":"2016-08-22T14:45:30.000Z","path":"2016/08/22/用SSH实现无密码自动登陆/","text":"SSH的公钥私钥问题 用SSH实现无密码自动登陆 SSH广泛用于脚本自动化，它使得我们可以在远程主机上执行命令并读取输出。SSH通常使用用户名和密码进行认证，在其执行过程中会提示输入密码。但是在自动化脚本中要求用户输入密码就显得不实际了。因此需要将登录过程自动化。SSH包含了一个内建特性，可以用SSH密钥实现自动登录。 1. 预备知识： SSH采用非对称加密技术，认证密钥包含两部分：一个公钥和一个私钥。我们可以通过ssh-keygen 命令创建认证密钥。想要实现自动化认证，公钥必须放置在服务器中（将其加入文件~/.ssh/authorized_keys），与公钥对应的私钥应该放入登录客户机的~/.ssh 目录中。另一些与SSH相关的配置信息（例如，arthorized_keys文件的路径与名称）可以通过修改文件/etc/ssh/sshd_config进行配置。 2. 实战演练： 设置SSH自动化认证需要两步： 1. 创建SSH密钥，这里用于登录远程主机； 2. 将生成的公钥传给远程主机，并将其加入文件~/.ssh/authorized_keys 中。 输入命令ssh-keygen 创建SSH密钥，并指定加密算法类型为RSA： 123456789101112131415161718192021$ ssh-keygen -t rsaGenerating public&#x2F;private rsa key pair.Enter file in which to save the key (&#x2F;home&#x2F;HELEN&#x2F;.ssh&#x2F;id_rsa):Enter passphrase (empty for no passphrase):Enter same passphrase again:Your identification has been saved in &#x2F;home&#x2F;HELEN&#x2F;.ssh&#x2F;id_rsa.Your public key has been saved in &#x2F;home&#x2F;HELEN&#x2F;.ssh&#x2F;id_rsa.pub.The key fingerprint is:SHA256:NKlL1KFVD867uAwLIAd01ujibgrwx18Q45FrFlOCV4Q HELEN@LuciferThe key&#39;s randomart image is:+---[RSA 2048]----+| . oo..+*.o ||. o...EB &#x3D; o ||. . .X &#x3D; o . || o . o X . . ||+ + O S . ||.&#x3D; o + o . . ||o . + o o . ||.o . o &#x3D; . ||+ o o |+----[SHA256]-----+ 你需要输入一个口令来生成一对公钥和私钥。如果不输入的话，也可以生成密钥，但是这样做可不安全。我们可以编写监控脚本，利用自动登陆来登入多台主机。对于这种情况，在运行ssh-keygen 命令时，不要填入口令，这样就能够避免在脚本运行时向你索要口令了。 现在~/.ssh/id_rsa.pub和~/.ssh/id_rsa 已经生成了。id_rsa.pub是生成的公钥，**i_rsa是生成的私钥。**公钥必须添加到远程服务器~/.ssh/authorized_keys 文件中，这台服务器也正是我们想从当前主机自动登入的那台服务器。 多数Linux发布版中有一个叫做 ssh-copy-di 的工具，它可以自动将公钥加入远程服务器的authorized_keys文件中。用法如下：ssh-copy-id USER@REMOTE_HOST","tags":[{"name":"ssh","slug":"ssh","permalink":"http://tech.noexception.cn/tags/ssh/"}]},{"title":"滑动菜单","date":"2016-08-22T14:38:23.000Z","path":"2016/08/22/滑动菜单/","text":"介绍滑动菜单的用法 预备： support v4包，继承自ViewGroup 示例： 样式一： 示例布局 1234567891011121314151617181920212223242526272829303132333435363738394041&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;android.support.v4.widget.SlidingPaneLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" xmlns:app=\"http://schemas.android.com/apk/res-auto\" android:id=\"@+id/SlidingPane\" android:layout_width=\"match_parent\" android:layout_height=\"match\" android:background=\"#D32F2F\"&gt; &lt;LinearLayout android:id=\"@+id/ll_menu\" android:gravity=\"center\" android:layout_width=\"200dp\" android:background=\"#d32f2f\" android:layout_height=\"match_parent\"&gt; &lt;TextView android:text=\"Menu\" android:textSize=\"25sp\" android:textColor=\"#ffffff\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" /&gt; &lt;/LinearLayout&gt; &lt;LinearLayout android:id=\"@+id/ll_main\" android:background=\"#ffffff\" android:orientation=\"vertical\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\"&gt; &lt;android.support.v7.widget.Toolbar android:id=\"@+id/toolbar\" android:layout_width=\"match_parent\" android:layout_height=\"?attr/actionBarSize\" android:background=\"@color/colorPrimary\" app:popupTheme=\"@style/ThemeOverlay.AppCompat.Light\" app:theme=\"@style/ThemeOverlay.AppCompat.Dark.ActionBar\"/&gt; &lt;/LinearLayout&gt;&lt;/android.support.v4.widget.SlidingPaneLayout&gt; SlidingPaneLayout 一些主要的方法： setParallaxDistance(int parallaxBy)设置滑动视差 setCoveredFadeColor(int color)导航菜单视图的滑动颜色渐变 setSliderFadeColor(int color)主视图的滑动颜色渐变 setPanelSlideListener(SlidingPanelLayou.PanelSlideListener listener)滑动监听 openPanel()打开导航菜单 closePanel()关闭导航菜单 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263public class SlidingPanelLayoutActivity extends AppCompatActivity &#123; private SlidingPaneLayout mSlidingPane; private LinearLayout ll_menu,ll_main; @Override protected void onCreate(@Nullable Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.first_layout); mSlidingPane=(SlidingPaneLayout)findViewById(R.id.SlidingPane); ll_main=(LinearLayout) findViewById(R.id.ll_main); ll_menu=(LinearLayout) findViewById(R.id.ll_menu); setSupportActionBar((Toolbar)findViewById(R.id.toolbar)); //设置滑动视差 可选 mSlidingPane.setParallaxDistance(200); //菜单滑动的颜色渐变设置 可选// mSlidingPane.setCoveredFadeColor(getResources().getColor(R.color.colorAccent)); //主视图滑动的颜色渐变设置 可选 mSlidingPane.setSliderFadeColor(0); //滑动监听 可选 mSlidingPane.setPanelSlideListener(new SlidingPaneLayout.PanelSlideListener()&#123; /** * Called when a sliding pane's position changes. * * @param panel The child view that was moved * @param slideOffset The new offset of this sliding pane within its range, from 0-1 */ @Override public void onPanelSlide(View panel, float slideOffset) &#123; Log.d(\"mylog\", \"slide---\"+slideOffset); //slideOffset这个参数是跟随滑动0-1变化的 //通过这个竖直变化我们可以做出一些不一样的滑动效果// ll_menu.setScaleY(slideOffset/2+0.5F);// ll_menu.setScaleX(slideOffset/2+0.5F);// ll_main.setScaleY(1-slideOffset/5); &#125; /** * Called when a sliding pane becomes slid completely open. The pane may or may not * be interactive at this point depending on how much of the pane is visible. * * @param panel The child view that was slid to an open position, revealing other panes */ @Override public void onPanelOpened(View panel) &#123; Log.d(\"mylog\",\"slide---open\"); &#125; /** * Called when a sliding pane becomes slid completely closed. The pane is now guaranteed * to be interactive. It may now obscure other views in the layout. * * @param panel The child view that was slid to a closed position */ @Override public void onPanelClosed(View panel) &#123; Log.d(\"mylog\",\"slide---close\"); &#125; &#125;); &#125;&#125; 这样就做出了互动导航的效果 注意：在滑动监听中的这个方法里，根据slideOffset参数0~1的变化可以去改变视图大小就会做出更多种类的效果，这里我们设置滑动过程中改变主视图的大小，代码如下： 1234567public void onPanelSlide(View panel, float slideOffset)&#123; //slideOffset这个参数是跟随滑动0~1变化的 //通过这个数值变化我们可以做出一些不一样的滑动效果 ll_menu.setScaleY(slideOffset/2+0.5F); ll_menu.setScaleX(slideOffset.2+0.5F); ll_main.setScaleY(1-slideOffset/5);&#125; 样式二： 快速实现这个效果需要利用V4包的DrawerLayout这个布局容器，可见V4包下面有多少好东西，另外其实SlidingPaneLayout和DrawerLayout都是利用V4的ViewDragHelper去实现的，这是一个帮助类，这里就不多介绍了，对它感兴趣的可以深入了解下。 示例布局： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" xmlns:tools=\"http://schemas.android.com/tools\" xmlns:app=\"http://schemas.android.com/apk/res-auto\" android:orientation=\"vertical\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\"&gt; &lt;android.support.v7.widget.Toolbar android:id=\"@+id/toolbar2\" android:layout_width=\"match_parent\" android:layout_height=\"?attr/actionBarSize\" android:background=\"@color/colorPrimary\" app:popupTheme=\"@style/ThemeOverlay.AppCompat.Light\" app:theme=\"@style/ThemeOverlay.AppCompat.Dark.ActionBar\"/&gt; &lt;android.support.v4.widget.DrawerLayout android:id=\"@+id/dl_left\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\"&gt; &lt;LinearLayout android:background=\"#ffffff\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\"&gt; &lt;/LinearLayout&gt; &lt;!--drawer layout--&gt; &lt;LinearLayout android:layout_width=\"200dp\" android:layout_height=\"match_parent\" android:background=\"#d32f2f\" android:layout_gravity=\"start\"&gt; &lt;TextView android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:text=\"Menu\" android:textSize=\"25sp\" android:gravity=\"center\" android:textColor=\"#ffffff\"/&gt; &lt;/LinearLayout&gt; &lt;/android.support.v4.widget.DrawerLayout&gt;&lt;/LinearLayout&gt; 需要注意的是主视图的布局代码要放在侧滑菜单布局的前面，侧滑菜单布局的代码中android:layout_gravity=&quot;start&quot;从左侧滑动，反之end右侧滑动 DrawerLayout的一些主要方法： addDrawerListener(DrawerLayout.DrawerListener listener)添加滑动监听 openDrawer(int gravity)开启导航菜单参数：GravityCompat.START GravityCompat.END要跟XML设置相同 closeDrawer(int gravity)关闭导航菜单 isDrawerOpen(int drawerGravity)菜单是否开启 123456789101112131415161718192021222324252627282930313233343536373839404142public class DrawerLayoutActivity extends AppCompatActivity &#123; private DrawerLayout drawerLayout; private Toolbar toolbar; @Override protected void onCreate(@Nullable Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.second_layout); setSupportActionBar(toolbar = (Toolbar) findViewById(R.id.toolbar2)); drawerLayout = (DrawerLayout)findViewById(R.id.dl_left); //ActionBarDrawerToggle是DrawerLayout.DrawerListener的实现 //可以方便的将drawlayout和actionbar结合起来 ActionBarDrawerToggle actionBarDrawerToggle = new ActionBarDrawerToggle(this,drawerLayout, toolbar, R.string.open, R.string.close)&#123; /** * &#123;@link DrawerLayout.DrawerListener&#125; callback method. If you do not use your * ActionBarDrawerToggle instance directly as your DrawerLayout's listener, you should call * through to this method from your own listener object. * * @param drawerView Drawer view that is now open */ @Override public void onDrawerOpened(View drawerView) &#123; super.onDrawerOpened(drawerView); &#125; /** * &#123;@link DrawerLayout.DrawerListener&#125; callback method. If you do not use your * ActionBarDrawerToggle instance directly as your DrawerLayout's listener, you should call * through to this method from your own listener object. * * @param drawerView Drawer view that is now closed */ @Override public void onDrawerClosed(View drawerView) &#123; super.onDrawerClosed(drawerView); &#125; &#125;; actionBarDrawerToggle.syncState(); drawerLayout.addDrawerListener(actionBarDrawerToggle); &#125;&#125; DrawerLayout跟ActionBarDrawerToggle配合快速就可以快速构建出具有动画交互的滑动导航菜单效果，是不是很简单。 当下的设计标准 接下来总结“当下”如何按照Android的设计标准去滑动导航菜单，我为什么说的“当下”呢？因为这个设计标准是会变的。 滑动导航菜单需要在Actionbar(Toolbar)下面，这在Android 4.X时代是比较常见的设计，也是当时Android Design标准设计。 ###实现步骤： 因为NavigationView在Design库中，需要添加依赖：compile 'com.android.support:design:24.0.0' 在DrawLayout 中添加 NavigationView: 布局： 1234567891011121314151617181920212223242526272829303132&lt;android.support.v4.widget.DrawerLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" xmlns:app=\"http://schemas.android.com/apk/res-auto\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:id=\"@+id/drawerlayout\" android:fitsSystemWindows=\"true\"&gt; &lt;LinearLayout android:id=\"@+id/ll_main\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:orientation=\"vertical\"&gt; &lt;android.support.v7.widget.Toolbar android:id=\"@+id/toolbar\" android:layout_width=\"match_parent\" android:layout_height=\"?attr/actionBarSize\" android:background=\"@color/colorPrimary\" app:popupTheme=\"@style/ThemeOverlay.AppCompat.Light\" app:theme=\"@style/ThemeOverlay.AppCompat.Dark.ActionBar\"/&gt; &lt;/LinearLayout&gt; &lt;android.support.design.widget.NavigationView android:id=\"@+id/navigationView\" android:layout_width=\"wrap_content\" android:layout_height=\"match_parent\" android:layout_gravity=\"start\" app:headerLayout=\"@layout/nv_header\" app:menu=\"@menu/main_drawer\"/&gt;&lt;/android.support.v4.widget.DrawerLayout&gt; 因为属于DrawLayout的导航菜单布局，所以NavigationView要加上android:layout_gravity=&quot;start&quot;代表从左面滑动，反之是&quot;end&quot;。 其中app:headerLayout=&quot;@layout/nv_header&quot;需要传入一个导航菜单的头部布局，它的作用如图绿框部分。。 12345678910111213141516171819202122232425262728293031323334353637383940414243//头部布局代码&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" android:orientation=\"vertical\" android:layout_width=\"match_parent\" android:layout_height=\"180dp\" android:background=\"@drawable/background_material\" android:gravity=\"bottom\" android:padding=\"16dp\"&gt; &lt;LinearLayout android:layout_marginTop=\"8dp\" android:layout_width=\"match_parent\" android:layout_height=\"0dp\" android:layout_weight=\"1\" android:gravity=\"center_vertical\"&gt; &lt;ImageView android:id=\"@+id/profile_image\" android:layout_width=\"76dp\" android:layout_height=\"76dp\" android:background=\"@drawable/z\"/&gt; &lt;/LinearLayout&gt; &lt;TextView android:text=\"xlucifer\" android:textSize=\"14sp\" android:textColor=\"#fff\" android:textStyle=\"bold\" android:paddingBottom=\"4dp\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" /&gt; &lt;TextView android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:text=\"1234567890\" android:textSize=\"14sp\" android:textColor=\"#fff\"/&gt;&lt;/LinearLayout&gt; app:menu=&quot;@menu/main_drawer&quot;用于设置导航菜单中的菜单部分。 123456789101112131415161718192021222324252627282930313233343536373839&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;menu xmlns:android=\"http://schemas.android.com/apk/res/android\"&gt;&lt;group&gt; &lt;item android:id=\"@+id/navigation_item1\" android:checkable=\"true\" android:title=\"First\" android:icon=\"@mipmap/ic_launcher\"/&gt; &lt;item android:id=\"@+id/navigation_item2\" android:checkable=\"true\" android:title=\"Second\" android:icon=\"@mipmap/ic_launcher\"/&gt; &lt;item android:id=\"@+id/navigation_item3\" android:checkable=\"true\" android:title=\"Third\" android:icon=\"@mipmap/ic_launcher\"/&gt; &lt;item android:id=\"@+id/navigation_item4\" android:checkable=\"true\" android:title=\"Fourth\" android:icon=\"@mipmap/ic_launcher\"/&gt; &lt;item android:id=\"@+id/navigation_sub\" android:title=\"其他\"&gt; &lt;menu&gt; &lt;item android:id=\"@+id/navigation_sub_item1\" android:checkable=\"true\" android:title=\"Fifth\" android:icon=\"@mipmap/ic_launcher\"/&gt; &lt;item android:id=\"@+id/navigation_sub_item2\" android:checkable=\"true\" android:title=\"Sixth\" android:icon=\"@mipmap/ic_launcher\"/&gt; &lt;item android:id=\"@+id/navigation_sub_item3\" android:checkable=\"true\" android:title=\"Seventh\" android:icon=\"@mipmap/ic_launcher\"/&gt; &lt;/menu&gt; &lt;/item&gt;&lt;/group&gt;&lt;/menu&gt; 最后是java中代码实现： 12345678910111213141516171819202122232425262728293031323334353637383940414243public class NavigationViewActivity extends AppCompatActivity &#123; private DrawerLayout drawerLayout; private Toolbar toolbar; private NavigationView navigationView; @Override protected void onCreate(@Nullable Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.drawlayout_activity); if(Build.VERSION.SDK_INT &gt; Build.VERSION_CODES.KITKAT)&#123; //透明状态栏 getWindow().addFlags(WindowManager.LayoutParams.FLAG_TRANSLUCENT_STATUS); &#125; setSupportActionBar(toolbar=(Toolbar)findViewById(R.id.toolbar)); drawerLayout=(DrawerLayout)findViewById(R.id.drawerlayout); navigationView=(NavigationView)findViewById(R.id.navigationView); ActionBarDrawerToggle actionBarDrawerToggle = new ActionBarDrawerToggle(this, drawerLayout, toolbar, R.string.open, R.string.close); actionBarDrawerToggle.syncState(); drawerLayout.addDrawerListener(actionBarDrawerToggle); //navigationView menu点击监听 navigationView.setNavigationItemSelectedListener(new NavigationView.OnNavigationItemSelectedListener()&#123; @Override public boolean onNavigationItemSelected(MenuItem menuItem) &#123; selectDrawerItem(menuItem); return true; &#125; &#125;); &#125; private void selectDrawerItem(MenuItem menuItem) &#123; switch (menuItem.getItemId())&#123; //... default: Toast.makeText(NavigationViewActivity.this, \"menu click\", Toast.LENGTH_SHORT).show(); break; &#125; menuItem.setChecked(true); drawerLayout.closeDrawers(); &#125;&#125; 其中下面代码和布局代码中的android:fitsSystemWindows=&quot;true&quot;起到一个半透明状态栏的作用，半透明状态栏效果有各种实现方式，google也没能给一个好的实现方式，后续可能会考虑写一个全面的了解透明状态效果的文章 1234if(Build.VERSION.SDK_INT &gt; Build.VERSION_CODES.KITKAT)&#123; //透明状态栏 getWindow().addFlags(WindowManager.LayoutParams.FLAG_TRANSLUCENT_STATUS);&#125;","tags":[{"name":"view","slug":"view","permalink":"http://tech.noexception.cn/tags/view/"}]},{"title":"Android Studio NDK的配置","date":"2016-08-21T18:52:50.000Z","path":"2016/08/22/First/","text":"环境的配置以及HelloWorld例程 新建Project，此处工程是最简单的一个MainActivity和一个layout文件，在工程里声明native方法。public static native String Hello(); 编译h头文件 View-&gt;Tool Windows-&gt;Terminal，进入工程目录。 cd app/src/main/java 2. 编译头文件javah -classpath D:/Android-ProjectsSetUp/MyNDK/app/src/main/java -d jni 包名.MainActivty -classpath:类所在目录 -d:输出目录 jni+包名+类名 编写C文件 新建JNI文件夹 实现头文件里的函数 - **将刚才的头文件复制到这个新的jni文件夹中** - 新建一个C源文件，实现代码（注：当时运行程序出了问题，不知道是我Rebulid还是真的是嫁了一个空的C源文件解决的问题。因为网上说要加一个在Jni文件夹中加一个空的源文件才能通过编译，如果你也出现了问题，加一个试试看能不能解决） 1234#include \"com_example_helen_ndkproject_MainActivity.h\"jstring Java_com_example_helen_ndkproject_MainActivity_sayHello(JNIEnv *env, jobject thiz)&#123; return (*env)-&gt;NewStringUTF(env, \"Hello from JNI !\");&#125; 配置一些信息 在local.properties文件中设置ndk路径 在bulid.gradle的android节点下加入ndk{ moduleName &quot;MyJni&quot;//这是module的名字 } 在gradle.properties下面增加一句话：android.useDeprecatedNdk=true 在MainActivty里说明调用这个NDKstatic { System.loadLibrary(&quot;MyJni&quot;);} 然后就可以运行MainActivty了 另外篇： 分平台配置编译（可选） 这一步不是必须的，你可以根据需要，对各个平台进行不同的编译配置，可以设置覆盖前面的编译选项（例如cFlags）。例如你只想编译指定平台的.so，而不是所有的平台。如下 12345678910111213141516171819android &#123; &#x2F;&#x2F; .. android settings .. productFlavors &#123; x86 &#123; ndk &#123; abiFilter &quot;x86&quot; &#125; &#125; arm &#123; ndk &#123; abiFilter &quot;armeabi-v7a&quot; &#125; &#125; mips &#123; ndk &#123; abiFilter &quot;mips&quot; &#125; &#125; &#125; &#125; &#x2F;&#x2F; android 其他篇： 默认情况下，你需要把C/C++源代码放在[module]/src/main/jni/路径下， 当然，你也可以自定义源代码路径： 12345android &#123; // .. android settings .. sourceSets.main &#123; jni.srcDirs 'src/main/source' &#125;&#125;","tags":[]}]